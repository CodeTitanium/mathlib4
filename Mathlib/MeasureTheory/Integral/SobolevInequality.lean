/-
Copyright (c) 2022 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn, Heather Macbeth
-/
import Mathlib.Analysis.Calculus.Deriv.Pi
import Mathlib.Analysis.Calculus.FDeriv.Measurable
import Mathlib.Analysis.InnerProductSpace.Calculus
import Mathlib.Data.Finset.Interval
import Mathlib.MeasureTheory.Integral.Bochner
import Mathlib.MeasureTheory.Integral.IntegralEqImproper
import Mathlib.MeasureTheory.Integral.MeanInequalities
import Mathlib.MeasureTheory.Measure.Haar.Unique
import Mathlib.Tactic.FunProp.AEMeasurable
import Mathlib.Tactic.FunProp.Measurable

/-!
# Gagliardo-Nirenberg-Sobolev inequality
-/


open scoped Classical BigOperators ENNReal NNReal Topology
open Set Function Finset MeasureTheory Measure Filter

noncomputable section

section fun_prop

attribute [fun_prop] ENNReal.continuous_coe ENNReal.continuous_rpow_const
  Measurable.coe_nnreal_ennreal Measurable.nnnorm
  measurable_fderiv
end fun_prop

section RPow

theorem NNReal.rpow_add_of_nonneg (x : ‚Ñù‚â•0) {y z : ‚Ñù} (hy : 0 ‚â§ y) (hz : 0 ‚â§ z) :
    x ^ (y + z) = x ^ y * x ^ z := by
  by_cases h : y + z = 0
  ¬∑ obtain rfl : y = 0 := by linarith
    obtain rfl : z = 0 := by linarith
    simp [h]
  ¬∑ exact rpow_add' _ h

theorem Real.nnnorm_rpow_of_nonneg {x y : ‚Ñù} (hx : 0 ‚â§ x) : ‚Äñx ^ y‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä ^ y := by
  ext; exact Real.norm_rpow_of_nonneg hx

theorem ENNReal.rpow_add_of_nonneg {x : ‚Ñù‚â•0‚àû} (y z : ‚Ñù) (hy : 0 ‚â§ y) (hz : 0 ‚â§ z) :
    x ^ (y + z) = x ^ y * x ^ z := by
  induction x using recTopCoe
  ¬∑ rcases hy.eq_or_lt with rfl|hy
    ¬∑ rw [rpow_zero, one_mul, zero_add]
    rcases hz.eq_or_lt with rfl|hz
    ¬∑ rw [rpow_zero, mul_one, add_zero]
    simp [top_rpow_of_pos, hy, hz, add_pos hy hz]
  simp [coe_rpow_of_nonneg, hy, hz, add_nonneg hy hz, NNReal.rpow_add_of_nonneg _ hy hz]

@[fun_prop]
theorem Real.continuous_rpow_const {q : ‚Ñù} (h : 0 < q) :
    Continuous (fun x : ‚Ñù => x ^ q) :=
  continuous_iff_continuousAt.mpr fun x ‚Ü¶ continuousAt_rpow_const x q (.inr h)

end RPow

namespace Filter

theorem eventually_of_isEmpty {Œ± : Type*} {p : Œ± ‚Üí Prop} [IsEmpty Œ±] {l : Filter Œ±} :
    ‚àÄ·∂† (x : Œ±) in l, p x :=
  eventually_of_forall <| fun x ‚Ü¶ isEmptyElim x

end Filter

section ContDiff

variable {ùïú E F : Type*} [NontriviallyNormedField ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E]
  [NormedAddCommGroup F] [NormedSpace ùïú F] {f : E ‚Üí F}

theorem contDiff_one_iff_hasFDerivAt : ContDiff ùïú 1 f ‚Üî
    ‚àÉ f' : E ‚Üí E ‚ÜíL[ùïú] F, Continuous f' ‚àß ‚àÄ x, HasFDerivAt f (f' x) x := by
  convert contDiff_succ_iff_hasFDerivAt using 4; simp

end ContDiff

section ClosedEmbedding
variable {Œπ : Type*} {Œ≤ : Œπ ‚Üí Type*} [DecidableEq Œπ]
  [(i : Œπ) ‚Üí TopologicalSpace (Œ≤ i)]
  (x : (i : Œπ) ‚Üí Œ≤ i) (i : Œπ) {s : Set (Œ≤ i)}

theorem forall_and_left {Œπ : Sort*} [Nonempty Œπ] {q : Prop} {p : Œπ ‚Üí Prop} :
    (‚àÄ x, q ‚àß p x) ‚Üî (q ‚àß ‚àÄ x, p x) := by rw [forall_and, forall_const]

theorem forall_and_right {Œπ : Sort*} [Nonempty Œπ] {p : Œπ ‚Üí Prop} {q : Prop} :
    (‚àÄ x, p x ‚àß q) ‚Üî (‚àÄ x, p x) ‚àß q := by rw [forall_and, forall_const]

theorem image_update : update x i '' s = Set.univ.pi (update (fun j ‚Ü¶ {x j}) i s) := by
  ext y
  simp [update_eq_iff, and_left_comm (a := _ ‚àà s), forall_update_iff, eq_comm (a := y _)]

theorem closedEmbedding_update [(i : Œπ) ‚Üí T1Space (Œ≤ i)] : ClosedEmbedding (update x i) := by
  apply closedEmbedding_of_continuous_injective_closed
  ¬∑ exact continuous_const.update i continuous_id
  ¬∑ exact update_injective x i
  ¬∑ intro s hs
    rw [image_update]
    apply isClosed_set_pi
    simp [forall_update_iff, hs, isClosed_singleton]

end ClosedEmbedding

section ContDiffAbsPow

open Asymptotics Real
variable {E : Type*} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ‚Ñù F]

theorem hasFDerivAt_norm_rpow (x : E) {p : ‚Ñù} (hp : 1 < p) :
    HasFDerivAt (fun x : E ‚Ü¶ ‚Äñx‚Äñ ^ p) ((p * ‚Äñx‚Äñ ^ (p - 2)) ‚Ä¢ innerSL ‚Ñù x) x := by
  by_cases hx : x = 0
  ¬∑ simp [hx]
    have h2p : 0 < p - 1 := sub_pos.mpr hp
    rw [HasFDerivAt, hasFDerivAtFilter_iff_isLittleO]
    simp [zero_lt_one.trans hp |>.ne']
    calc (fun x : E ‚Ü¶ ‚Äñx‚Äñ ^ p) =
      (fun x : E ‚Ü¶ ‚Äñx‚Äñ * ‚Äñx‚Äñ ^ (p - 1)) := by
          ext x
          rw [‚Üê rpow_one_add' (norm_nonneg x) (by positivity)]
          ring_nf
      _ =o[ùìù 0] (fun x : E ‚Ü¶ ‚Äñx‚Äñ * 1) := by
        refine (isBigO_refl _ _).mul_isLittleO <| (isLittleO_const_iff <| by norm_num).mpr ?_
        convert continuousAt_id.norm.rpow_const (.inr h2p.le) |>.tendsto
        simp [h2p.ne']
      _ =O[ùìù 0] id := by
        simp_rw [mul_one, isBigO_norm_left (f' := fun x ‚Ü¶ x), id_def, isBigO_refl]
  ¬∑ apply HasStrictFDerivAt.hasFDerivAt
    convert (hasStrictFDerivAt_norm_sq x).rpow_const (p := p / 2) (by simp [hx]) using 0
    simp_rw [‚Üê Real.rpow_natCast_mul (norm_nonneg _), nsmul_eq_smul_cast ‚Ñù, smul_smul]
    ring_nf -- doesn't close the goal?
    congr! 2
    ring

theorem hasDerivAt_norm_rpow (x : ‚Ñù) {p : ‚Ñù} (hp : 1 < p) :
    HasDerivAt (fun x : ‚Ñù ‚Ü¶ ‚Äñx‚Äñ ^ p) (p * ‚Äñx‚Äñ ^ (p - 2) * x) x := by
  convert hasFDerivAt_norm_rpow x hp |>.hasDerivAt using 1; simp

theorem hasDerivAt_abs_rpow (x : ‚Ñù) {p : ‚Ñù} (hp : 1 < p) :
    HasDerivAt (fun x : ‚Ñù ‚Ü¶ |x| ^ p) (p * |x| ^ (p - 2) * x) x := by
  simpa using hasDerivAt_norm_rpow x hp

theorem fderiv_norm_rpow (x : E) {p : ‚Ñù} (hp : 1 < p) :
    fderiv ‚Ñù (fun x ‚Ü¶ ‚Äñx‚Äñ ^ p) x = (p * ‚Äñx‚Äñ ^ (p - 2)) ‚Ä¢ innerSL ‚Ñù x :=
  hasFDerivAt_norm_rpow x hp |>.fderiv

theorem Differentiable.fderiv_norm_rpow {f : F ‚Üí E} (hf : Differentiable ‚Ñù f)
    {x : F} {p : ‚Ñù} (hp : 1 < p) :
    fderiv ‚Ñù (fun x ‚Ü¶ ‚Äñf x‚Äñ ^ p) x =
    (p * ‚Äñf x‚Äñ ^ (p - 2)) ‚Ä¢ (innerSL ‚Ñù (f x)).comp (fderiv ‚Ñù f x) :=
  hasFDerivAt_norm_rpow (f x) hp |>.comp x (hf x).hasFDerivAt |>.fderiv

theorem norm_fderiv_norm_rpow_le {f : F ‚Üí E} (hf : Differentiable ‚Ñù f) {x : F} {p : ‚Ñù} (hp : 1 < p) :
    ‚Äñfderiv ‚Ñù (fun x ‚Ü¶ ‚Äñf x‚Äñ ^ p) x‚Äñ ‚â§ p * ‚Äñf x‚Äñ ^ (p - 1) * ‚Äñfderiv ‚Ñù f x‚Äñ := by
  rw [hf.fderiv_norm_rpow hp, norm_smul, norm_mul]
  simp [- Real.norm_eq_abs, Real.norm_rpow_of_nonneg]
  simp [abs_eq_self.mpr <| zero_le_one.trans hp.le, mul_assoc]
  gcongr _ * ?_
  refine mul_le_mul_of_nonneg_left (ContinuousLinearMap.opNorm_comp_le ..) (by positivity)
    |>.trans_eq ?_
  rw [innerSL_apply_norm, ‚Üê mul_assoc, ‚Üê Real.rpow_add_one' (by positivity) (by linarith)]
  ring_nf

theorem norm_fderiv_norm_id_rpow_le {x : E} {p : ‚Ñù} (hp : 1 < p) :
    ‚Äñfderiv ‚Ñù (fun x ‚Ü¶ ‚Äñx‚Äñ ^ p) x‚Äñ ‚â§ p * ‚Äñx‚Äñ ^ (p - 1) := by
  refine norm_fderiv_norm_rpow_le differentiable_id' hp |>.trans ?_
  rw [mul_assoc, fderiv_id']
  gcongr
  exact mul_le_mul_of_nonneg_left ContinuousLinearMap.norm_id_le (by positivity)
    |>.trans_eq (mul_one _)

theorem nnnorm_fderiv_norm_rpow_le {f : F ‚Üí E} (hf : Differentiable ‚Ñù f)
    {x : F} {p : ‚Ñù‚â•0} (hp : 1 < p) :
    ‚Äñfderiv ‚Ñù (fun x ‚Ü¶ ‚Äñf x‚Äñ ^ (p : ‚Ñù)) x‚Äñ‚Çä ‚â§ p * ‚Äñf x‚Äñ‚Çä ^ ((p : ‚Ñù) - 1) * ‚Äñfderiv ‚Ñù f x‚Äñ‚Çä :=
  norm_fderiv_norm_rpow_le hf hp

attribute [fun_prop] continuousAt_rpow_const Continuous.clm_comp

-- todo: generalize 1 to n
theorem contDiff_norm_rpow {p : ‚Ñù} (hp : 1 < p) : ContDiff ‚Ñù 1 (fun x : E ‚Ü¶ ‚Äñx‚Äñ ^ p) := by
  rw [contDiff_one_iff_fderiv]
  refine ‚ü®fun x ‚Ü¶ hasFDerivAt_norm_rpow x hp |>.differentiableAt, ?_‚ü©
  simp_rw [continuous_iff_continuousAt]
  intro x
  by_cases hx : x = 0
  ¬∑ simp [hx, ContinuousAt, fderiv_norm_rpow (E := E) (x := 0) hp]
    rw [tendsto_zero_iff_norm_tendsto_zero]
    refine tendsto_of_tendsto_of_tendsto_of_le_of_le (tendsto_const_nhds) ?_
      (fun _ ‚Ü¶ norm_nonneg _) (fun _ ‚Ü¶ norm_fderiv_norm_id_rpow_le hp)
    suffices ContinuousAt (fun x : E ‚Ü¶ p * ‚Äñx‚Äñ ^ (p - 1)) 0  by
      simpa [ContinuousAt, sub_ne_zero_of_ne hp.ne'] using this
    fun_prop (discharger := simp [*])
  ¬∑ simp_rw [funext fun x ‚Ü¶ fderiv_norm_rpow (E:=E) (x:=x) hp]
    fun_prop (discharger := simp [*])

theorem ContDiff.norm_rpow {f : F ‚Üí E} (hf : ContDiff ‚Ñù 1 f) {p : ‚Ñù} (hp : 1 < p) :
    ContDiff ‚Ñù 1 (fun x ‚Ü¶ ‚Äñf x‚Äñ ^ p) :=
  contDiff_norm_rpow hp |>.comp hf

theorem Differentiable.norm_rpow {f : F ‚Üí E} (hf : Differentiable ‚Ñù f) {p : ‚Ñù} (hp : 1 < p) :
    Differentiable ‚Ñù (fun x ‚Ü¶ ‚Äñf x‚Äñ ^ p) :=
  contDiff_norm_rpow hp |>.differentiable le_rfl |>.comp hf

end ContDiffAbsPow

namespace HasCompactSupport
variable {Œ± Œ≤ : Type*} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [AddGroup Œ≤] [Lattice Œ≤]
  [CovariantClass Œ≤ Œ≤ (¬∑ + ¬∑) (¬∑ ‚â§ ¬∑)]

protected theorem abs {f : Œ± ‚Üí Œ≤} (hf : HasCompactSupport f) : HasCompactSupport |f| :=
  hf.comp_left (g := abs) abs_zero

protected theorem rpow_const {f : Œ± ‚Üí ‚Ñù} (hf : HasCompactSupport f) {r : ‚Ñù} (hr : r ‚â† 0) :
    HasCompactSupport (fun x ‚Ü¶ f x ^ r) :=
  hf.comp_left (g := (¬∑ ^ r)) (Real.zero_rpow hr)
variable (ùïú : Type*) {E : Type*} {F : Type*} [NontriviallyNormedField ùïú] [NormedAddCommGroup E]
  [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F] {f : E ‚Üí F}
protected theorem fderiv_apply (hf : HasCompactSupport f) (v : E) :
    HasCompactSupport (fderiv ùïú f ¬∑ v) :=
  hf.fderiv ùïú |>.comp_left (g := fun L : E ‚ÜíL[ùïú] F ‚Ü¶ L v) rfl

end HasCompactSupport

section

variable {E : Type*} [NormedAddCommGroup E] {p : ‚Ñù‚â•0‚àû}

theorem Continuous.mem‚Ñíp_of_hasCompactSupport
    {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]
    {f : X ‚Üí E} (hf : Continuous f) (h'f : HasCompactSupport f) (Œº : Measure X)
    [IsFiniteMeasureOnCompacts Œº] : Mem‚Ñíp f p Œº := by
  have := hf.mem‚Ñíp_top_of_hasCompactSupport h'f Œº
  exact this.mem‚Ñíp_of_exponent_le_of_measure_support_ne_top
    (fun x ‚Ü¶ image_eq_zero_of_nmem_tsupport) (h'f.measure_lt_top.ne) le_top

end

namespace ENNReal

protected theorem inv_mul_le_iff {x y z : ‚Ñù‚â•0‚àû} (h1 : x ‚â† 0) (h2 : x ‚â† ‚àû) :
    x‚Åª¬π * y ‚â§ z ‚Üî y ‚â§ x * z := by
  rw [‚Üê mul_le_mul_left h1 h2, ‚Üê mul_assoc, ENNReal.mul_inv_cancel h1 h2, one_mul]

protected theorem mul_inv_le_iff {x y z : ‚Ñù‚â•0‚àû} (h1 : y ‚â† 0) (h2 : y ‚â† ‚àû) :
    x * y‚Åª¬π ‚â§ z ‚Üî x ‚â§ z * y := by
  rw [mul_comm, ENNReal.inv_mul_le_iff h1 h2, mul_comm]

protected theorem div_le_iff {x y z : ‚Ñù‚â•0‚àû} (h1 : y ‚â† 0) (h2 : y ‚â† ‚àû) :
    x / y ‚â§ z ‚Üî x ‚â§ z * y := by
  rw [div_eq_mul_inv, ENNReal.mul_inv_le_iff h1 h2]

protected theorem div_le_iff' {x y z : ‚Ñù‚â•0‚àû} (h1 : y ‚â† 0) (h2 : y ‚â† ‚àû) :
    x / y ‚â§ z ‚Üî x ‚â§ y * z := by
  rw [mul_comm, ENNReal.div_le_iff h1 h2]

end ENNReal

namespace Real.IsConjExponent

variable {p q : ‚Ñù} (h : IsConjExponent p q)
lemma conj_inv_eq : q‚Åª¬π = 1 - p‚Åª¬π := by
  rw [eq_sub_iff_add_eq, add_comm, h.inv_add_inv_conj]

end Real.IsConjExponent

namespace MeasureTheory

variable {Œ± E : Type*} [NormedAddCommGroup E] {_ : MeasurableSpace Œ±}
  {f : Œ± ‚Üí E} {Œº : Measure Œ±}

lemma snorm_nnreal_eq_snorm' {p : ‚Ñù‚â•0} (hp : p ‚â† 0) : snorm f p Œº = snorm' f p Œº :=
  snorm_eq_snorm' (by exact_mod_cast hp) ENNReal.coe_ne_top

lemma snorm_nnreal_eq_lintegral {p : ‚Ñù‚â•0} (hp : p ‚â† 0) :
    snorm f p Œº = (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ^ (p : ‚Ñù) ‚àÇŒº) ^ (1 / (p : ‚Ñù)) :=
  snorm_nnreal_eq_snorm' hp

lemma snorm_nnreal_pow_eq_lintegral {p : ‚Ñù‚â•0} (hp : p ‚â† 0) :
    snorm f p Œº ^ (p : ‚Ñù) = ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ^ (p : ‚Ñù) ‚àÇŒº := by
  simp [snorm_eq_snorm' (by exact_mod_cast hp) ENNReal.coe_ne_top,
    lintegral_rpow_nnnorm_eq_rpow_snorm' (show 0 < (p : ‚Ñù) from pos_iff_ne_zero.mpr hp)]

end MeasureTheory

namespace MeasureTheory

end MeasureTheory

section NormedAddCommGroup
variable {Œπ : Type*} [DecidableEq Œπ] [Fintype Œπ] {E : Œπ ‚Üí Type _} [‚àÄ i, NormedAddCommGroup (E i)]

theorem Pi.nnnorm_single {i : Œπ} (y : E i) : ‚ÄñPi.single i y‚Äñ‚Çä = ‚Äñy‚Äñ‚Çä := by
  classical
  have H : ‚àÄ b, ‚Äñsingle i y b‚Äñ‚Çä = single (f := fun _ ‚Ü¶ ‚Ñù‚â•0) i ‚Äñy‚Äñ‚Çä b := by
    intro b
    refine Pi.apply_single (fun i (x : E i) ‚Ü¶ ‚Äñx‚Äñ‚Çä) ?_ i y b
    simp
  simp [Pi.nnnorm_def, H, Pi.single_apply, Finset.sup_ite,
    Finset.filter_eq' (Finset.univ : Finset Œπ)]

theorem Pi.norm_single {i : Œπ} (y : E i) : ‚ÄñPi.single i y‚Äñ = ‚Äñy‚Äñ :=
  congr_arg Subtype.val (Pi.nnnorm_single y)

end NormedAddCommGroup

section updateFinset

variable {Œπ : Sort _} {œÄ Œ± : Œπ ‚Üí Sort _} {x : ‚àÄ i, œÄ i} [DecidableEq Œπ]

-- this would be slightly nicer if we had a version of `Equiv.piFinsetUnion` for `insert`.
theorem update_updateFinset {s y i z} (hi : i ‚àâ s) :
    Function.update (updateFinset x s y) i z = updateFinset x (s ‚à™ {i})
      ((Equiv.piFinsetUnion œÄ <| Finset.disjoint_singleton_right.mpr hi) (y, uniqueElim z)) := by
  rw [update_eq_updateFinset, updateFinset_updateFinset]

theorem updateFinset_congr {s t : Finset Œπ} {y : ‚àÄ i : s, œÄ i} (h : s = t) :
    updateFinset x s y = updateFinset x t (fun i ‚Ü¶ y ‚ü®i, h ‚ñ∏ i.prop‚ü©) := by
  subst h; rfl

theorem updateFinset_univ [Fintype Œπ] {y : ‚àÄ i : Finset.univ, œÄ i} :
    updateFinset x .univ y = fun i : Œπ ‚Ü¶ y ‚ü®i, Finset.mem_univ i‚ü© := by
  simp [updateFinset_def]

lemma Finset.singleton_union {s : Finset Œπ} {i : Œπ} : {i} ‚à™ s = insert i s := by ext; simp
lemma Finset.union_singleton {s : Finset Œπ} {i : Œπ} : s ‚à™ {i} = insert i s := by ext; simp [or_comm]

namespace Equiv
-- todo: rename `Finset.union_symm_inl`, `Finset.union_symm_inr`

theorem Finset.union_symm_left {s t : Finset Œπ} (h : Disjoint s t) {i : Œπ} (hi : i ‚àà s)
  (hi' : i ‚àà s ‚à™ t) : (Equiv.Finset.union s t h).symm ‚ü®i, hi'‚ü© = Sum.inl ‚ü®i, hi‚ü© := by
  simp [Equiv.symm_apply_eq]

theorem Finset.union_symm_right {s t : Finset Œπ} (h : Disjoint s t) {i : Œπ} (hi : i ‚àà t)
  (hi' : i ‚àà s ‚à™ t) : (Equiv.Finset.union s t h).symm ‚ü®i, hi'‚ü© = Sum.inr ‚ü®i, hi‚ü© := by
  simp [Equiv.symm_apply_eq]

lemma piFinsetUnion_left {Œπ} [DecidableEq Œπ] (Œ± : Œπ ‚Üí Type*) {s t : Finset Œπ}
    (h : Disjoint s t) {f g} {i : Œπ} (hi : i ‚àà s) (hi' : i ‚àà s ‚à™ t) :
    Equiv.piFinsetUnion Œ± h (f, g) ‚ü®i, hi'‚ü© = f ‚ü®i, hi‚ü© := by
  simp [Equiv.piFinsetUnion, eqRec_eq_cast]
  -- painful dependent type manipulations. The library hasn't much to help
  show cast ?h' ((sumPiEquivProdPi fun b ‚Ü¶ Œ± ‚Üë((Finset.union s t h) b)).symm (f, g) _) = _
  generalize ?h' = h'
  set x := ((Finset.union s t h).symm { val := i, property := hi' })
  have : x = Sum.inl ‚ü®i, hi‚ü© := Finset.union_symm_left h hi hi'
  show cast h' ((sumPiEquivProdPi fun b ‚Ü¶ Œ± ‚Üë((Finset.union s t h) b)).symm (f, g) x) = _
  clear_value x
  subst this
  rfl

lemma piFinsetUnion_right {Œπ} [DecidableEq Œπ] (Œ± : Œπ ‚Üí Type*) {s t : Finset Œπ}
    (h : Disjoint s t) {f g} {i : Œπ} (hi : i ‚àà t) (hi' : i ‚àà s ‚à™ t) :
    Equiv.piFinsetUnion Œ± h (f, g) ‚ü®i, hi'‚ü© = g ‚ü®i, hi‚ü© := by
  simp [Equiv.piFinsetUnion, eqRec_eq_cast]
  -- painful dependent type manipulations. The library hasn't much to help
  show cast ?h' ((sumPiEquivProdPi fun b ‚Ü¶ Œ± ‚Üë((Finset.union s t h) b)).symm (f, g) _) = _
  generalize ?h' = h'
  set x := ((Finset.union s t h).symm { val := i, property := hi' })
  have : x = Sum.inr ‚ü®i, hi‚ü© := Finset.union_symm_right h hi hi'
  show cast h' ((sumPiEquivProdPi fun b ‚Ü¶ Œ± ‚Üë((Finset.union s t h) b)).symm (f, g) x) = _
  clear_value x
  subst this
  rfl

end Equiv

end updateFinset

variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]

local prefix:max "#" => Fintype.card

/-! ## The grid-lines lemma -/

variable {A : Œπ ‚Üí Type*} [‚àÄ i, MeasurableSpace (A i)]
  (Œº : ‚àÄ i, Measure (A i)) [‚àÄ i, SigmaFinite (Œº i)]

namespace GridLines

/-- The "grid-lines operation" (not a standard name) which is central in the inductive proof of the
Sobolev inequality.

For a finite dependent product `Œ† i : Œπ, A i` of sigma-finite measure spaces, a finite set `s` of
indices from `Œπ`, and a (later assumed nonnegative) real number `p`, this operation acts on a
function `f` from `Œ† i, A i` into the extended nonnegative reals.  The operation is to partially
integrate, in the `s` co-ordinates, the function whose value at `x : Œ† i, A i` is obtained by
multiplying a certain power of `f` with the product, for each co-ordinate `i` in `s`, of a certain
power of the integral of `f` along the "grid line" in the `i` direction through `x`.

We are most interested in this operation when the set `s` is the universe in `Œπ`, but as a proxy for
"induction on dimension" we define it for a general set `s` of co-ordinates: the `s`-grid-lines
operation on a function `f` which is constant along the co-ordinates in `s·∂ú` is morally (that is, up
to type-theoretic nonsense) the same thing as the universe-grid-lines operation on the associated
function on the "lower-dimensional" space `Œ† i : s, A i`. -/
def T (p : ‚Ñù) (f : (‚àÄ i, A i) ‚Üí ‚Ñù‚â•0‚àû) (s : Finset Œπ) : (‚àÄ i, A i) ‚Üí ‚Ñù‚â•0‚àû :=
  ‚à´‚ãØ‚à´‚Åª_s, f ^ (1 - (s.card - 1 : ‚Ñù) * p) * ‚àè i in s, (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) ^ p ‚àÇŒº

variable {p : ‚Ñù}

@[simp] lemma T_univ (f : (‚àÄ i, A i) ‚Üí ‚Ñù‚â•0‚àû) (x : ‚àÄ i, A i) :
    T Œº p f univ x
    = ‚à´‚Åª (x : ‚àÄ i, A i), (f x ^ (1 - (#Œπ - 1 : ‚Ñù) * p)
      * ‚àè i : Œπ, (‚à´‚Åª t : A i, f (update x i t) ‚àÇ(Œº i)) ^ p) ‚àÇ(.pi Œº) := by
  simp [T, lmarginal_univ, lmarginal_singleton, card_univ]

@[simp] lemma T_empty (f : (‚àÄ i, A i) ‚Üí ‚Ñù‚â•0‚àû) (x : ‚àÄ i, A i) :
    T Œº p f ‚àÖ x = f x ^ (1 + p) := by
  simp [T]

/-- The main inductive step in the grid-lines lemma for the Gagliardo-Nirenberg-Sobolev inequality.

The grid-lines operation `GridLines.T` on a nonnegative function on a finitary product type is
less than or equal to the grid-lines operation of its partial integral in one co-ordinate
(the latter intuitively considered as a function on a space "one dimension down"). -/
theorem T_insert_le_T_lmarginal_singleton (hp‚ÇÄ : 0 ‚â§ p) (s : Finset Œπ)
    (hp : (s.card : ‚Ñù) * p ‚â§ 1)
    (i : Œπ) (hi : i ‚àâ s) {f : (‚àÄ i, A i) ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    T Œº p f (insert i s) ‚â§ T Œº p (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) s := by
  calc T Œº p f (insert i s)
      = ‚à´‚ãØ‚à´‚Åª_insert i s,
            f ^ (1 - (s.card : ‚Ñù) * p) * ‚àè j in (insert i s), (‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) ^ p ‚àÇŒº := by
          simp_rw [T, card_insert_of_not_mem hi]
          congr!
          push_cast
          ring
    _ = ‚à´‚ãØ‚à´‚Åª_s, (fun x ‚Ü¶ ‚à´‚Åª (t : A i),
            (f (update x i t) ^ (1 - (s.card : ‚Ñù) * p)
            * ‚àè j in (insert i s), (‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) (update x i t) ^ p)  ‚àÇ (Œº i)) ‚àÇŒº := by
          rw [lmarginal_insert' _ _ hi]
          ¬∑ congr! with x t
            simp only [Pi.mul_apply, Pi.pow_apply, Finset.prod_apply]
          ¬∑ change Measurable (fun x ‚Ü¶ _)
            simp only [Pi.mul_apply, Pi.pow_apply, Finset.prod_apply]
            refine (hf.pow_const _).mul <| Finset.measurable_prod _ ?_
            exact fun _ _ ‚Ü¶ hf.lmarginal Œº |>.pow_const _
    _ ‚â§ T Œº p (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) s := lmarginal_mono (s:=s) (fun x ‚Ü¶ ?_)
  simp only [Pi.mul_apply, Pi.pow_apply, Finset.prod_apply]
  have hF‚ÇÅ : ‚àÄ {j : Œπ}, Measurable fun t ‚Ü¶ (‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) (update x i t) :=
    fun {_} ‚Ü¶ hf.lmarginal Œº |>.comp <| measurable_update _
  have hF‚ÇÄ : Measurable fun t ‚Ü¶ f (update x i t) := hf.comp <| measurable_update _
  let k : ‚Ñù := s.card
  have hk' : 0 ‚â§ 1 - k * p := by linarith only [hp]
  let X := update x i
  calc ‚à´‚Åª t, f (X t) ^ (1 - k * p)
          * ‚àè j in (insert i s), (‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) (X t) ^ p ‚àÇ (Œº i)
      = ‚à´‚Åª t, (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) (X t) ^ p * (f (X t) ^ (1 - k * p)
          * ‚àè j in s, ((‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) (X t) ^ p)) ‚àÇ(Œº i) := by
              -- rewrite integrand so that `(‚à´‚ãØ‚à´‚Åª_insert i s, f ‚àÇŒº) ^ p` comes first
              clear_value X
              congr! 2 with t
              simp_rw [prod_insert hi]
              ring_nf
    _ = (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x ^ p *
          ‚à´‚Åª t, f (X t) ^ (1 - k * p) * ‚àè j in s, ((‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) (X t)) ^ p ‚àÇ(Œº i) := by
              -- pull out this constant factor
              have : ‚àÄ t, (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) (X t) = (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x := by
                intro t
                rw [lmarginal_update_of_mem]
                exact Iff.mpr Finset.mem_singleton rfl
              simp_rw [this]
              rw [lintegral_const_mul]
              exact (hF‚ÇÄ.pow_const _).mul <| Finset.measurable_prod _ fun _ _ ‚Ü¶ hF‚ÇÅ.pow_const _
    _ ‚â§ (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x ^ p *
          ((‚à´‚Åª t, f (X t) ‚àÇŒº i) ^ (1 - k * p)
          * ‚àè j in s, (‚à´‚Åª t, (‚à´‚ãØ‚à´‚Åª_{j}, f ‚àÇŒº) (X t) ‚àÇŒº i) ^ p) := by
              -- apply H√∂lder's inequality
              gcongr
              apply ENNReal.lintegral_mul_prod_norm_pow_le
              ¬∑ exact hF‚ÇÄ.aemeasurable
              ¬∑ intros
                exact hF‚ÇÅ.aemeasurable
              ¬∑ simp only [sum_const, nsmul_eq_mul]
                ring
              ¬∑ exact hk'
              ¬∑ exact fun _ _ ‚Ü¶ hp‚ÇÄ
    _ = (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x ^ p *
          ((‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x ^ (1 - k * p) * ‚àè j in s, (‚à´‚ãØ‚à´‚Åª_{i, j}, f ‚àÇŒº) x ^ p) := by
              -- absorb the newly-created integrals into `‚à´‚ãØ‚à´`
              dsimp only
              congr! 2
              ¬∑ rw [lmarginal_singleton]
              refine prod_congr rfl fun j hj => ?_
              have hi' : i ‚àâ ({j} : Finset Œπ) := by
                simp only [Finset.mem_singleton, Finset.mem_insert, Finset.mem_compl] at hj ‚ä¢
                exact fun h ‚Ü¶ hi (h ‚ñ∏ hj)
              rw [lmarginal_insert _ hf hi']
    _ = (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x ^ (p + (1 - k * p)) *  ‚àè j in s, (‚à´‚ãØ‚à´‚Åª_{i, j}, f ‚àÇŒº) x ^ p := by
              -- combine two `(‚à´‚ãØ‚à´‚Åª_insert i s, f ‚àÇŒº) x` terms
              rw [ENNReal.rpow_add_of_nonneg]
              ¬∑ ring
              ¬∑ exact hp‚ÇÄ
              ¬∑ exact hk'
    _ ‚â§ (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) x ^ (1 - (s.card - 1 : ‚Ñù) * p) *
          ‚àè j in s, (‚à´‚ãØ‚à´‚Åª_{j}, (‚à´‚ãØ‚à´‚Åª_{i}, f ‚àÇŒº) ‚àÇŒº) x ^ p := by
              -- identify the result with the RHS integrand
              congr! 2 with j hj
              ¬∑ push_cast
                ring_nf
              ¬∑ congr! 1
                rw [‚Üê lmarginal_union Œº f hf]
                ¬∑ congr
                  rw [Finset.union_comm]
                  rfl
                ¬∑ rw [Finset.disjoint_singleton]
                  simp only [Finset.mem_insert, Finset.mem_compl] at hj
                  exact fun h ‚Ü¶ hi (h ‚ñ∏ hj)

/-- Auxiliary result for the grid-lines lemma.  Given a nonnegative function on a finitary product
type indexed by `Œπ`, and a set `s` in `Œπ`, consider partially integrating over the variables in
`s·∂ú` and performing the "grid-lines operation" (see `GridLines.T`) to the resulting function in the
variables `s`.  This theorem states that this operation decreases as the number of grid-lines taken
increases. -/
theorem T_lmarginal_antitone (hp‚ÇÄ : 0 ‚â§ p) (hp : (#Œπ - 1 : ‚Ñù) * p ‚â§ 1)
    {f : (‚àÄ i, A i) ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    Antitone (fun s ‚Ü¶ T Œº p (‚à´‚ãØ‚à´‚Åª_s·∂ú, f ‚àÇŒº) s) := by
  -- Reformulate (by induction): a function is decreasing on `Finset Œπ` if it decreases under the
  -- insertion of any element to any set.
  rw [Finset.antitone_iff_forall_insert_le]
  intro s i hi
  -- apply the lemma designed to encapsulate the inductive step
  convert T_insert_le_T_lmarginal_singleton Œº hp‚ÇÄ s ?_ i hi (hf.lmarginal Œº) using 2
  ¬∑ rw [‚Üê lmarginal_union Œº f hf]
    ¬∑ rw [‚Üê insert_compl_insert hi]
      rfl
    rw [Finset.disjoint_singleton_left, not_mem_compl]
    exact mem_insert_self i s
  ¬∑ -- the main nontrivial point is to check that an exponent `p` satisfying `0 ‚â§ p` and
    -- `(#Œπ - 1) * p ‚â§ 1` is in the valid range for the inductive-step lemma
    refine le_trans ?_ hp
    gcongr
    suffices (s.card : ‚Ñù) + 1 ‚â§ #Œπ by linarith
    rw [‚Üê card_add_card_compl s]
    norm_cast
    gcongr
    have hi' : s·∂ú.Nonempty := ‚ü®i, by rwa [Finset.mem_compl]‚ü©
    rwa [‚Üê card_pos] at hi'

end GridLines

/-- The "grid-lines lemma" (not a standard name), stated with a general parameter `p` as the
exponent.  Compare with `lintegral_prod_lintegral_pow_le`.

For any finite dependent product `Œ† i : Œπ, A i` of sigma-finite measure spaces, for any
nonnegative real number `p` such that `(#Œπ - 1) * p ‚â§ 1`, for any function `f` from `Œ† i, A i` into
the extended nonnegative reals, we consider an associated "grid-lines quantity", the integral of an
associated function from `Œ† i, A i` into the extended nonnegative reals.  The value of this function
at `x : Œ† i, A i` is obtained by multiplying a certain power of `f` with the product, for each
co-ordinate `i`, of a certain power of the integral of `f` along the "grid line" in the `i`
direction through `x`.

This lemma bounds the Lebesgue integral of the grid-lines quantity by a power of the Lebesgue
integral of `f`. -/
theorem lintegral_mul_prod_lintegral_pow_le {p : ‚Ñù} (hp‚ÇÄ : 0 ‚â§ p)
    (hp : (#Œπ - 1 : ‚Ñù) * p ‚â§ 1) {f : (‚àÄ i : Œπ, A i) ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    ‚à´‚Åª x, f x ^ (1 - (#Œπ - 1 : ‚Ñù) * p) * ‚àè i, (‚à´‚Åª x·µ¢, f (update x i x·µ¢) ‚àÇŒº i) ^ p ‚àÇ.pi Œº
    ‚â§ (‚à´‚Åª x, f x ‚àÇ.pi Œº) ^ (1 + p) := by
  cases isEmpty_or_nonempty (‚àÄ i, A i)
  ¬∑ simp_rw [lintegral_of_isEmpty]; refine' zero_le _
  inhabit ‚àÄ i, A i
  have H : (‚àÖ : Finset Œπ) ‚â§ Finset.univ := Finset.empty_subset _
  simpa [lmarginal_univ] using GridLines.T_lmarginal_antitone Œº hp‚ÇÄ hp hf H default

/-- Special case of the grid-lines lemma `lintegral_mul_prod_lintegral_pow_le`, taking the extremal
exponent `p = (#Œπ - 1)‚Åª¬π`. -/
theorem lintegral_prod_lintegral_pow_le [Nontrivial Œπ]
    {p : ‚Ñù} (hp : Real.IsConjExponent #Œπ p)
    {f} (hf : Measurable f) :
    ‚à´‚Åª x, ‚àè i, (‚à´‚Åª x·µ¢, f (update x i x·µ¢) ‚àÇŒº i) ^ ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) ‚àÇ.pi Œº
    ‚â§ (‚à´‚Åª x, f x ‚àÇ.pi Œº) ^ p := by
  have h0 : (1:‚Ñù) < #Œπ := by norm_cast; exact Fintype.one_lt_card
  have h1 : (0:‚Ñù) < #Œπ - 1 := by linarith
  have h3 : 0 ‚â§ ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := by positivity
  have h4 : (#Œπ - 1 : ‚Ñù) * ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) ‚â§ 1 := by field_simp
  have h5 : p = 1 + 1 / (‚Üë#Œπ - 1) := by field_simp; rw [mul_comm, hp.sub_one_mul_conj]
  rw [h5]
  convert lintegral_mul_prod_lintegral_pow_le Œº h3 h4 hf using 2
  field_simp

/-! ## The Gagliardo-Nirenberg-Sobolev inequality -/

variable [Nontrivial Œπ] {F : Type*} [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [CompleteSpace F]

/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable
compactly-supported function `u` on `‚Ñù‚Åø`, for `n ‚â• 2`.  (More literally we encode `‚Ñù‚Åø` as
`Œπ ‚Üí ‚Ñù` where `n := #Œπ` is finite and at least 2.)  Then the Lebesgue integral of the pointwise
expression `|u x| ^ (n / (n - 1))` is bounded above by the `n / (n - 1)`-th power of the Lebesgue
integral of the Fr√©chet derivative of `u`.

For a basis-free version, see `lintegral_pow_le_pow_lintegral_fderiv`. -/
theorem lintegral_pow_le_pow_lintegral_fderiv_aux
    {p : ‚Ñù} (hp : Real.IsConjExponent #Œπ p)
    {u : (Œπ ‚Üí ‚Ñù) ‚Üí F} (hu : ContDiff ‚Ñù 1 u)
    (h2u : HasCompactSupport u) :
    ‚à´‚Åª x, (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p ‚â§ (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä) ^ p := by
  have : (1:‚Ñù) ‚â§ ‚Üë#Œπ - 1 := by
    have hŒπ : (2:‚Ñù) ‚â§ #Œπ := by exact_mod_cast Fintype.one_lt_card
    linarith
  calc ‚à´‚Åª x, (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p
      = ‚à´‚Åª x, ((‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ (1 / (#Œπ - 1 : ‚Ñù))) ^ (#Œπ : ‚Ñù) := by
        -- a little algebraic manipulation of the exponent
        congr! 2 with x
        rw [‚Üê ENNReal.rpow_mul, hp.conj_eq]
        field_simp
    _ = ‚à´‚Åª x, ‚àè _i : Œπ, (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ (1 / (#Œπ - 1 : ‚Ñù)) := by
        -- express the left-hand integrand as a product of identical factors
        congr! 2 with x
        simp_rw [prod_const, card_univ]
        norm_cast
    _ ‚â§ ‚à´‚Åª x, ‚àè i, (‚à´‚Åª x·µ¢, ‚Äñfderiv ‚Ñù u (update x i x·µ¢)‚Äñ‚Çä) ^ ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := ?_
    _ ‚â§ (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä) ^ p :=
        -- apply the grid-lines lemma
        lintegral_prod_lintegral_pow_le _ hp (by fun_prop)
  gcongr with x i
  calc (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)
      = (‚Äñ‚à´ x·µ¢ in Iic (x i), deriv (u ‚àò update x i) x·µ¢‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := by
        -- apply the half-infinite fundamental theorem of calculus
        have h3u : ContDiff ‚Ñù 1 (u ‚àò update x i) := hu.comp (by convert contDiff_update 1 x i)
        have h4u : HasCompactSupport (u ‚àò update x i) :=
          h2u.comp_closedEmbedding (closedEmbedding_update x i)
        simp [HasCompactSupport.integral_Iic_deriv_eq h3u h4u (x i)]
    _ ‚â§ ‚à´‚Åª x·µ¢ in Iic (x i), ‚Äñderiv (u ‚àò update x i) x·µ¢‚Äñ‚Çä :=
        ennnorm_integral_le_lintegral_ennnorm _ -- apply the triangle inequality
    _ ‚â§ ‚à´‚Åª x·µ¢, (‚Äñfderiv ‚Ñù u (update x i x·µ¢)‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := ?_
  gcongr with y; swap; exact Measure.restrict_le_self
  -- bound the derivative which appears
  calc ‚Äñderiv (u ‚àò update x i) y‚Äñ‚Çä = ‚Äñfderiv ‚Ñù u (update x i y) (deriv (update x i) y)‚Äñ‚Çä := by
        rw [fderiv.comp_deriv _ (hu.differentiable le_rfl).differentiableAt
          (hasDerivAt_update x i y).differentiableAt]
    _ ‚â§ ‚Äñfderiv ‚Ñù u (update x i y)‚Äñ‚Çä * ‚Äñderiv (update x i) y‚Äñ‚Çä :=
        ContinuousLinearMap.le_opNNNorm ..
    _ ‚â§ ‚Äñfderiv ‚Ñù u (update x i y)‚Äñ‚Çä := by simp [deriv_update, Pi.nnnorm_single]

variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [MeasurableSpace E] [BorelSpace E]
  [FiniteDimensional ‚Ñù E] (Œº : Measure E) [IsAddHaarMeasure Œº]

open FiniteDimensional

section

example (c : ‚Ñù‚â•0) (Œº : Measure E) : c ‚Ä¢ Œº = (c : ‚Ñù‚â•0‚àû) ‚Ä¢ Œº := by rw [@ENNReal.smul_def]

set_option linter.unusedVariables false in
variable (F) in
/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable
compactly-supported function `u` on a normed space `E` of finite dimension `n ‚â• 2`, equipped
with Haar measure. There exists a constant `C` depending only on `E`, such that the Lebesgue
integral of the pointwise expression `|u x| ^ (n / (n - 1))` is bounded above by `C` times the
`n / (n - 1)`-th power of the Lebesgue integral of the Fr√©chet derivative of `u`. -/
theorem lintegral_pow_le_pow_lintegral_fderiv (hE : 2 ‚â§ finrank ‚Ñù E)
    {p : ‚Ñù} (hp : Real.IsConjExponent (finrank ‚Ñù E) p) :
    ‚àÉ C : ‚Ñù‚â•0, ‚àÄ {u : E ‚Üí F} (hu : ContDiff ‚Ñù 1 u) (h2u : HasCompactSupport u),
    ‚à´‚Åª x, (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p ‚àÇŒº ‚â§ C * (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä ‚àÇŒº) ^ p := by
  -- we reduce to the case of `E = Œπ ‚Üí ‚Ñù`, for which we have already proved the result using
  -- matrices in `lintegral_pow_le_pow_lintegral_fderiv_aux`.
  let Œπ := Fin (finrank ‚Ñù E)
  have hŒπcard : #Œπ = finrank ‚Ñù E := Fintype.card_fin (finrank ‚Ñù E)
  have : Nontrivial Œπ := by rwa [Fin.nontrivial_iff_two_le]
  have : FiniteDimensional ‚Ñù (Œπ ‚Üí ‚Ñù) := by infer_instance
  have : finrank ‚Ñù E = finrank ‚Ñù (Œπ ‚Üí ‚Ñù) := by simp
  have e : E ‚âÉL[‚Ñù] Œπ ‚Üí ‚Ñù := ContinuousLinearEquiv.ofFinrankEq this
  have : IsAddHaarMeasure ((volume : Measure (Œπ ‚Üí ‚Ñù)).map e.symm) :=
    (e.symm : (Œπ ‚Üí ‚Ñù) ‚âÉ+ E).isAddHaarMeasure_map _ e.symm.continuous e.symm.symm.continuous
  have hp : Real.IsConjExponent #Œπ p := by rwa [hŒπcard]
  have h0p : 0 ‚â§ p := hp.symm.nonneg
  let c := addHaarScalarFactor Œº ((volume : Measure (Œπ ‚Üí ‚Ñù)).map e.symm)
  have hc : 0 < c := addHaarScalarFactor_pos_of_isAddHaarMeasure ..
  have h2c : Œº = c ‚Ä¢ ((volume : Measure (Œπ ‚Üí ‚Ñù)).map e.symm) := isAddLeftInvariant_eq_smul ..
  have h3c : (c : ‚Ñù‚â•0‚àû) ‚â† 0 := by simp_rw [ne_eq, ENNReal.coe_eq_zero, hc.ne', not_false_eq_true]
  have : ‚àÉ C : ‚Ñù‚â•0, C * c ^ p = c * ‚Äñ(e.symm : (Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä ^ p := by
    use (c * ‚Äñ(e.symm : (Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä ^ p) * (c ^ p)‚Åª¬π
    rw [inv_mul_cancel_right‚ÇÄ]
    exact (NNReal.rpow_pos hc).ne'
  refine this.imp fun C hC u hu h2u ‚Ü¶ ?_
  rw [h2c, ENNReal.smul_def, lintegral_smul_measure, lintegral_smul_measure]
  let v : (Œπ ‚Üí ‚Ñù) ‚Üí F := u ‚àò e.symm
  have hv : ContDiff ‚Ñù 1 v := hu.comp e.symm.contDiff
  have h2v : HasCompactSupport v := h2u.comp_homeomorph e.symm.toHomeomorph
  have :=
  calc ‚à´‚Åª x, (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p ‚àÇ(volume : Measure (Œπ ‚Üí ‚Ñù)).map e.symm
      = ‚à´‚Åª y, (‚Äñv y‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ p := by
        refine lintegral_map ?_ e.symm.continuous.measurable
        borelize F
        exact hu.continuous.measurable.nnnorm.coe_nnreal_ennreal.pow_const _
    _ ‚â§ (‚à´‚Åª y, ‚Äñfderiv ‚Ñù v y‚Äñ‚Çä) ^ p :=
        lintegral_pow_le_pow_lintegral_fderiv_aux hp hv h2v
    _ = (‚à´‚Åª y, ‚Äñ(fderiv ‚Ñù u (e.symm y)).comp (fderiv ‚Ñù e.symm y)‚Äñ‚Çä) ^ p := by
        congr! with y
        apply fderiv.comp _ (hu.differentiable le_rfl _)
        exact e.symm.differentiableAt
    _ ‚â§ (‚à´‚Åª y, ‚Äñfderiv ‚Ñù u (e.symm y)‚Äñ‚Çä * ‚Äñ(e.symm : (Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä) ^ p := by
        gcongr with y
        norm_cast
        rw [e.symm.fderiv]
        apply ContinuousLinearMap.opNNNorm_comp_le
    _ = (‚Äñ(e.symm : (Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä * ‚à´‚Åª y, ‚Äñfderiv ‚Ñù u (e.symm y)‚Äñ‚Çä) ^ p := by
        rw [lintegral_mul_const, mul_comm]
        refine (Continuous.nnnorm ?_).measurable.coe_nnreal_ennreal
        exact (hu.continuous_fderiv le_rfl).comp e.symm.continuous
    _ = (‚Äñ(e.symm : (Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä ^ p : ‚Ñù‚â•0) * (‚à´‚Åª y, ‚Äñfderiv ‚Ñù u (e.symm y)‚Äñ‚Çä) ^ p := by
        rw [ENNReal.mul_rpow_of_nonneg _ _ h0p, ENNReal.coe_rpow_of_nonneg _ h0p]
    _ = (‚Äñ(e.symm : (Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä ^ p : ‚Ñù‚â•0)
        * (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä ‚àÇ(volume : Measure (Œπ ‚Üí ‚Ñù)).map e.symm) ^ p := by
        congr
        rw [lintegral_map _ e.symm.continuous.measurable]
        fun_prop
  rw [‚Üê ENNReal.mul_le_mul_left h3c ENNReal.coe_ne_top, ‚Üê mul_assoc, ‚Üê ENNReal.coe_mul, ‚Üê hC,
    ENNReal.coe_mul] at this
  rw [ENNReal.mul_rpow_of_nonneg _ _ h0p, ‚Üê mul_assoc, ENNReal.coe_rpow_of_ne_zero hc.ne']
  exact this

set_option linter.unusedVariables false in
variable (F) in
/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable
compactly-supported function `u` on a normed space `E` of finite dimension `n ‚â• 2`, equipped
with Haar measure. There exists a constant `C` depending only on `E`, such that the `L·µñ` norm of
`u`, where `p := n / (n - 1)`, is bounded above by `C` times the `L¬π` norm of the Fr√©chet derivative
of `u`. -/
theorem snorm_le_snorm_fderiv (hE : 2 ‚â§ finrank ‚Ñù E)
    {p : ‚Ñù‚â•0} (hp : NNReal.IsConjExponent (finrank ‚Ñù E) p) :
    ‚àÉ C : ‚Ñù‚â•0, ‚àÄ {u : E ‚Üí F} (hu : ContDiff ‚Ñù 1 u) (h2u : HasCompactSupport u),
    snorm u p Œº ‚â§ C * snorm (fderiv ‚Ñù u) 1 Œº := by
  obtain ‚ü®m, hm‚ü© : ‚àÉ m, finrank ‚Ñù E = m + 2 := Nat.exists_eq_add_of_le' hE
  have h0p : 0 < (p : ‚Ñù) := hp.coe.symm.pos
  obtain ‚ü®C, hC‚ü© := lintegral_pow_le_pow_lintegral_fderiv F Œº hE hp.coe
  use C ^ (p : ‚Ñù)‚Åª¬π
  intro u hu h2u
  rw [snorm_one_eq_lintegral_nnnorm,
    ‚Üê ENNReal.rpow_le_rpow_iff h0p, ENNReal.mul_rpow_of_nonneg _ _ h0p.le,
    ENNReal.coe_rpow_of_nonneg _ h0p.le, ‚Üê NNReal.rpow_mul,
    snorm_nnreal_pow_eq_lintegral hp.symm.pos.ne',
    inv_mul_cancel h0p.ne', NNReal.rpow_one]
  exact hC hu h2u

variable (F' : Type*) [NormedAddCommGroup F'] [InnerProductSpace ‚Ñù F'] [CompleteSpace F']
set_option linter.unusedVariables false in
/-- The **Gagliardo-Nirenberg-Sobolev inequality**.  Let `u` be a continuously differentiable
compactly-supported function `u` on a normed space `E` of finite dimension `n`, equipped
with Haar measure, let `1 < p < n` and let `p'‚Åª¬π := p‚Åª¬π - n‚Åª¬π`.
There exists a constant `C` depending only on `E` and `p`, such that the `L·µñ'` norm of `u`
is bounded above by `C` times the `L·µñ` norm of the Fr√©chet derivative of `u`.

Note: The codomain of `u` needs to be an inner product space.
-/
theorem snorm_le_snorm_fderiv_of_eq {p p' : ‚Ñù‚â•0} (hp : 1 ‚â§ p)
    (h2p : p < finrank ‚Ñù E) (hp' : (p' : ‚Ñù)‚Åª¬π = p‚Åª¬π - (finrank ‚Ñù E : ‚Ñù)‚Åª¬π) :
    ‚àÉ C : ‚Ñù‚â•0, ‚àÄ {u : E ‚Üí F'} (hu : ContDiff ‚Ñù 1 u) (h2u : HasCompactSupport u),
    snorm u p' Œº ‚â§ C * snorm (fderiv ‚Ñù u) p Œº := by
  set n := finrank ‚Ñù E
  let n' := NNReal.conjExponent n
  have h0n : 2 ‚â§ n := Nat.succ_le_of_lt <| Nat.one_lt_cast.mp <| hp.trans_lt h2p
  have hn : NNReal.IsConjExponent n n' := .conjExponent (by norm_cast)
  have h1n : 1 ‚â§ (n : ‚Ñù‚â•0) := hn.one_le
  have h2n : (0 : ‚Ñù) < n - 1 := by simp_rw [sub_pos]; exact hn.coe.one_lt
  have hnp : (0 : ‚Ñù) < n - p := by simp_rw [sub_pos]; exact h2p
  rcases hp.eq_or_lt with rfl|hp
  -- the case `p = 1`
  ¬∑ obtain ‚ü®C, hC‚ü© := snorm_le_snorm_fderiv F' Œº h0n hn
    refine ‚ü®C, @fun u hu h2u ‚Ü¶ ?_‚ü©
    convert hC hu h2u
    ext
    rw [‚Üê inv_inj, hp']
    field_simp [NNReal.conjExponent]
  -- the case `p > 1`
  let q := Real.conjExponent p
  have hq : Real.IsConjExponent p q := .conjExponent hp
  have h0p : p ‚â† 0 := zero_lt_one.trans hp |>.ne'
  have h1p : (p : ‚Ñù) ‚â† 1 := hq.one_lt.ne'
  -- have h3p : (p : ‚Ñù) ‚â† 0 := hq.pos.ne'
  have h3p : (p : ‚Ñù) - 1 ‚â† 0 := sub_ne_zero_of_ne h1p
  have h0p' : p' ‚â† 0 := by
    suffices 0 < (p' : ‚Ñù) from (show 0 < p' from this) |>.ne'
    rw [‚Üê inv_pos, hp', sub_pos]
    exact inv_lt_inv_of_lt hq.pos h2p
  have h2q : 1 / n' - 1 / q = 1 / p' := by
    simp_rw (config := {zeta := false}) [one_div, hp']
    rw [hq.conj_inv_eq, hn.coe.conj_inv_eq, sub_sub_sub_cancel_left]
    simp
  let Œ≥ : ‚Ñù‚â•0 := ‚ü®p * (n - 1) / (n - p), by positivity‚ü©
  have h0Œ≥ : (Œ≥ : ‚Ñù) = p * (n - 1) / (n - p) := rfl
  have h1Œ≥ : 1 < (Œ≥ : ‚Ñù) := by
    rwa [h0Œ≥, one_lt_div hnp, mul_sub, mul_one, sub_lt_sub_iff_right, lt_mul_iff_one_lt_left]
    exact hn.coe.pos
  have h2Œ≥ : Œ≥ * n' = p' := by
    rw [‚Üê NNReal.coe_inj, ‚Üê inv_inj, hp', NNReal.coe_mul, h0Œ≥, hn.coe.conj_eq]
    field_simp; ring
  have h3Œ≥ : (Œ≥ - 1) * q = p' := by
    rw [‚Üê inv_inj, hp', h0Œ≥, hq.conj_eq]
    have : (p : ‚Ñù) * (n - 1) - (n - p) = n * (p - 1) := by ring
    field_simp; rw [this]; field_simp; ring
  have h4Œ≥ : (Œ≥ : ‚Ñù) ‚â† 0 := (zero_lt_one.trans h1Œ≥).ne'
  obtain ‚ü®C, hC‚ü© := snorm_le_snorm_fderiv ‚Ñù Œº h0n hn
  refine ‚ü®C * Œ≥, @fun u hu h2u ‚Ü¶ ?_‚ü©
  by_cases h3u : ‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº = 0
  ¬∑ rw [snorm_nnreal_eq_lintegral h0p', h3u, ENNReal.zero_rpow_of_pos] <;> positivity
  have h4u : ‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº ‚â† ‚àû := by
    refine lintegral_rpow_nnnorm_lt_top_of_snorm'_lt_top (pos_iff_ne_zero.mpr h0p') ?_ |>.ne
    dsimp only
    rw [NNReal.val_eq_coe, ‚Üê snorm_nnreal_eq_snorm' h0p']
    exact hu.continuous.mem‚Ñíp_of_hasCompactSupport (Œº := Œº) h2u |>.snorm_lt_top
  have h5u : (‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº) ^ (1 / q) ‚â† 0 :=
    ENNReal.rpow_pos (pos_iff_ne_zero.mpr h3u) h4u |>.ne'
  have h6u : (‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº) ^ (1 / q) ‚â† ‚àû :=
    ENNReal.rpow_ne_top_of_nonneg (div_nonneg zero_le_one hq.symm.nonneg) h4u
  have h7u := hu.continuous -- for fun_prop
  have h8u := (hu.fderiv_right (m := 0) le_rfl).continuous -- for fun_prop
  let v : E ‚Üí ‚Ñù := fun x ‚Ü¶ ‚Äñu x‚Äñ ^ (Œ≥ : ‚Ñù)
  have hv : ContDiff ‚Ñù 1 v := hu.norm_rpow h1Œ≥
  have h2v : HasCompactSupport v := h2u.norm.rpow_const h4Œ≥
  have :=
  calc (‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº) ^ (1 / (n' : ‚Ñù)) = snorm v n' Œº := by
        rw [‚Üê h2Œ≥, snorm_nnreal_eq_lintegral hn.symm.pos.ne']
        congr! 3
        simp [Real.nnnorm_rpow_of_nonneg, ENNReal.rpow_mul]
        rw [ENNReal.coe_rpow_of_nonneg]
        positivity
    _ ‚â§ C * snorm (fderiv ‚Ñù v) 1 Œº := hC hv h2v
    _ = C * ‚à´‚Åª x, ‚Äñfderiv ‚Ñù v x‚Äñ‚Çä ‚àÇŒº := by rw [snorm_one_eq_lintegral_nnnorm]
    _ ‚â§ C * Œ≥ * ‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ ((Œ≥ : ‚Ñù) - 1) * ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä ‚àÇŒº := by
      rw [mul_assoc, ‚Üê lintegral_const_mul Œ≥]
      gcongr
      simp_rw [‚Üê mul_assoc, ENNReal.coe_rpow_of_nonneg _ (sub_nonneg.mpr h1Œ≥.le)]
      exact ENNReal.coe_le_coe.mpr <| nnnorm_fderiv_norm_rpow_le (hu.differentiable le_rfl) h1Œ≥
      fun_prop
    _ ‚â§ C * Œ≥ * ((‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº) ^ (1 / q) *
        (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä ^ (p : ‚Ñù) ‚àÇŒº) ^ (1 / (p : ‚Ñù))) := by
        gcongr
        convert ENNReal.lintegral_mul_le_Lp_mul_Lq Œº
          (.symm <| .conjExponent <| show 1 < (p : ‚Ñù) from hp) ?_ ?_ using 5
        ¬∑ simp_rw [‚Üê ENNReal.rpow_mul, ‚Üê h3Œ≥]
        ¬∑ borelize F'
          fun_prop
        ¬∑ fun_prop
    _ = C * Œ≥ * (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä ^ (p : ‚Ñù) ‚àÇŒº) ^ (1 / (p : ‚Ñù)) *
      (‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº) ^ (1 / q) := by ring
  calc
    snorm u p' Œº = (‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ (p' : ‚Ñù) ‚àÇŒº) ^ (1 / (p' : ‚Ñù)) := snorm_nnreal_eq_lintegral h0p'
    _ ‚â§ C * Œ≥ * (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä ^ (p : ‚Ñù) ‚àÇŒº) ^ (1 / (p : ‚Ñù)) :=
      by rwa [‚Üê h2q, ENNReal.rpow_sub _ _ h3u h4u, ENNReal.div_le_iff h5u h6u]
    _ = C * Œ≥ *  snorm (fderiv ‚Ñù u) (‚Üëp) Œº := by rw [snorm_nnreal_eq_lintegral h0p]
