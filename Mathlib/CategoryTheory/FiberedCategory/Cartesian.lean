/-
Copyright (c) 2024 Paul Lezeau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Lezeau, Calle Sรถnne
-/

import Mathlib.CategoryTheory.FiberedCategory.HomLift

/-!

# Fibered categories

This file defines what it means for a functor `p : ๐ณ โฅค ๐ฎ` to be fibered`.

## Main definitions

- `IsCartesian p f ฯ` expresses that `ฯ` is a cartesian arrow lying over `f` with respect to `p`.
This structure extends `IsHomLift p f ฯ`.
- `IsFibered p` expresses that `p` gives `๐ณ` the structure of a fibered category over `๐ฎ`, i.e.
that for every morphism `f : S โถ R` in `๐ฎ` and every object `b` in `๐ณ` with `p(b)=R` there is a
cartesian arrow `ฯ : a โถ b`  of `f`.

## Implementation
The standard constructors of `IsCartesian` and `IsFibered` have both been renamed to `.mk'`. We have
provided alternate lemmas `IsCartesian.mk` and `IsFibered.mk` for constructing instances of these
structures, and it is recommended to use these instead to minimize the amount of equalities that
needs to be carried around in the construction.

The reason for this is the following:
Just like `IsHomLift p f ฯ`, we have phrased `IsCartesian p f ฯ` in a way to make its usage as
flexible  as possible with respect to non-definitional equalities of domains / codomains.
In particular, given a lift
```
  a --ฯ--> b
  -        -
  |        |
  v        v
  R --f--> S
```
(by which we mean an object of `IsHomLift p f ฯ`). We say that it is cartesian if for all arrows
`g : R' โถ R`, and all lifts
```
  a' --ฯ'--> b
  -          -
  |          |
  v          v
  R' --f'--> S
```
such that `f' = g โซ f`, there is a unique induced map `ฯ : a' โถ a` lifting `g` and such that
`ฯ โซ ฯ = ฯ'`. This definition gives us some flexibility in that it allows us to take `f'` to be
non-definitionally equal to `g โซ f`, and `p(a')` to be non-definitionally equal to `R'`.
`IsCartesian.mk` only requires us to check this condition for `f' = g โซ f` and `R=p(a')`.

Similarly, `IsFibered p` is phrased as saying that for every `f : R โถ S`, and every `a` such that
`p(a)=S`, there is a cartesian arrow `ฯ` lying over `f`. The alternate constructor `IsFibered.mk`
only requires us to construct this arrow for every `a` and every `f : R โถ p(a)`.
-/

universe vโ vโ uโ uโ

open CategoryTheory Functor Category IsHomLift

namespace CategoryTheory

variable {๐ฎ : Type uโ} {๐ณ : Type uโ} [Category.{vโ} ๐ฎ] [Category.{vโ} ๐ณ]

/-- The proposition that a lift
```
  a --ฯ--> b
  -        -
  |        |
  v        v
  R --f--> S
```
is a cartesian arrow, see SGA 1, VI.5.1.
-/
class Functor.IsCartesian (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b) extends
    IsHomLift p f ฯ : Prop where
  universal_property {a' : ๐ณ} (ฯ' : a' โถ b) [IsHomLift p f ฯ'] :
      โ! ฯ : a' โถ a, IsHomLift p (๐ R) ฯ โง ฯ โซ ฯ = ฯ'

/-- The proposition that a lift
```
  a --ฯ--> b
  -        -
  |        |
  v        v
  R --f--> S
```
is a strongly cartesian arrow, see STACKS PROJECT. -/
class Functor.IsStronglyCartesian (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    extends IsHomLift p f ฯ : Prop where mk' ::
  universal_property {R' : ๐ฎ} {a' : ๐ณ} (g : R' โถ R) (f' : R' โถ S)
    (_ : f' = g โซ f) (ฯ' : a' โถ b) [IsHomLift p f' ฯ'] :
      โ! ฯ : a' โถ a, IsHomLift p g ฯ โง ฯ โซ ฯ = ฯ'

protected lemma IsStronglyCartesian.mk {p : ๐ณ โฅค ๐ฎ} {R S : ๐ฎ} {a b : ๐ณ} {f : R โถ S} {ฯ : b โถ a}
    [IsHomLift p f ฯ] (h : โ (a' : ๐ณ) (g : p.obj a' โถ R) (ฯ' : a' โถ a), IsHomLift p (g โซ f) ฯ' โ
      โ! ฯ : a' โถ b, IsHomLift p g ฯ โง ฯ โซ ฯ = ฯ') : IsStronglyCartesian p f ฯ where
  universal_property := by
    intro R' a' g f' hf' ฯ' hฯ'
    subst_hom_lift p f' ฯ'
    apply h a' g ฯ' (hf' โธ inferInstance)

instance cartesian_of_stronglyCartesian (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [p.IsStronglyCartesian f ฯ] : p.IsCartesian f ฯ where
  universal_property := fun ฯ' =>
    IsStronglyCartesian.universal_property (ฯ:=ฯ) (f:=f) (๐ R) f (by simp) ฯ'


namespace IsCartesian

/-- Given an arrow `ฯ' : a' โถ b` and a diagram:
```
a'        a --ฯ--> b
|         |        |
v         v        v
R' ====== R --f--> S
```
such that `ฯ` is a cartesian arrow, then `inducedMap f ฯ ฯ'` is the map `a' โถ a`
obtained from the universal property of `ฯ`. -/
noncomputable def inducedMap (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsCartesian p f ฯ] {a' : ๐ณ} (ฯ' : a' โถ b) [IsHomLift p f ฯ'] : a' โถ a :=
  Classical.choose <| IsCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) ฯ'

instance inducedMap_isHomLift (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsCartesian p f ฯ] {a' : ๐ณ} (ฯ' : a' โถ b) [IsHomLift p f ฯ'] :
      IsHomLift p (๐ R) (inducedMap p f ฯ ฯ') :=
  (Classical.choose_spec <| IsCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) ฯ').1.1

@[simp]
lemma inducedMap_comp (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsCartesian p f ฯ] {a' : ๐ณ} (ฯ' : a' โถ b) [IsHomLift p f ฯ'] :
      (inducedMap p f ฯ ฯ') โซ ฯ = ฯ' :=
  (Classical.choose_spec <| IsCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) ฯ').1.2

/-- Given a diagram:
```
a'        a --ฯ--> b
|         |        |
v         v        v
R' ====== R --f--> S
```
with `ฯ` a cartesian arrow. Then for any arrow `ฯ' : a' โถ b`, and `ฯ : a' โถ a` such that
`g โซ ฯ = ฯ'`. Then `ฯ` is the map induced by the universal property of `ฯ`. -/
lemma inducedMap_unique (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsCartesian p f ฯ] {a' : ๐ณ} (ฯ' : a' โถ b) [IsHomLift p f ฯ']
    (ฯ : a' โถ a) [IsHomLift p (๐ R) ฯ] (hฯ : ฯ โซ ฯ = ฯ') : ฯ = inducedMap p f ฯ ฯ' :=
  (Classical.choose_spec <| IsCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) ฯ').2
    ฯ โจinferInstance, hฯโฉ

/-- Given a diagram:
```
a'        a --ฯ--> b
|         |        |
v         v        v
R' ====== R --f--> S
```
with `ฯ` a cartesian arrow. Then for any arrow `ฯ' : a' โถ b`, any two arrows `ฯ ฯ' : a' โถ a` such
that `g โซ ฯ = ฯ' = g โซ ฯ'`. Then `ฯ = ฯ'`. -/
protected lemma uniqueness (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsCartesian p f ฯ] {a' : ๐ณ} (ฯ' : a' โถ b) [IsHomLift p f ฯ'] {ฯ ฯ' : a' โถ a}
    [IsHomLift p (๐ R) ฯ] [IsHomLift p (๐ R) ฯ'] (hcomp : ฯ โซ ฯ = ฯ') (hcomp' : ฯ' โซ ฯ = ฯ') :
      ฯ = ฯ' := by
  rw [inducedMap_unique p f ฯ ฯ' ฯ hcomp, inducedMap_unique p f ฯ ฯ' ฯ' hcomp']

@[simp]
lemma inducedMap_self_eq_id (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsCartesian p f ฯ] : inducedMap p f ฯ ฯ = ๐ a := by
  subst_hom_lift p f ฯ; symm
  apply inducedMap_unique
  simp only [id_comp]

end IsCartesian

namespace IsStronglyCartesian

/-- Given a diagram:
```
a'        a --ฯ--> b
|         |        |
v         v        v
R' --g--> R --f--> S
```
such that `ฯ` is a cartesian arrow, and an arrow `ฯ' : a' โถ b`,
the induced map is the map `a' โถ a` obtained from the
universal property of `ฯ`. -/
noncomputable def inducedMap (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] {R' : ๐ฎ} {a' : ๐ณ} {g : R' โถ R} {f' : R' โถ S} (hf' : f' = g โซ f)
    (ฯ' : a' โถ b) [IsHomLift p f' ฯ'] : a' โถ a :=
  Classical.choose <| IsStronglyCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) _ _ hf' ฯ'

instance inducedMap_isHomLift (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] {R' : ๐ฎ} {a' : ๐ณ} {g : R' โถ R} {f' : R' โถ S} (hf' : f' = g โซ f)
    (ฯ' : a' โถ b) [IsHomLift p f' ฯ'] : IsHomLift p g (inducedMap p f ฯ hf' ฯ') :=
  (Classical.choose_spec <|
    IsStronglyCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) _ _ hf' ฯ').1.1

@[simp]
lemma inducedMap_comp (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] {R' : ๐ฎ} {a' : ๐ณ} {g : R' โถ R} {f' : R' โถ S} (hf' : f' = g โซ f)
    (ฯ' : a' โถ b) [IsHomLift p f' ฯ'] : (inducedMap p f ฯ hf' ฯ') โซ ฯ = ฯ' :=
  (Classical.choose_spec <|
    IsStronglyCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) _ _ hf' ฯ').1.2

/-- Given a diagram:
```
a'        a --ฯ--> b
|         |        |
v         v        v
R' --g--> R --f--> S
```
with `ฯ` a cartesian arrow. Then for any arrow `ฯ' : a' โถ b`, and `ฯ : a' โถ a` such that
`g โซ ฯ = ฯ'`. Then `ฯ` is the map induced by the universal property. -/
lemma inducedMap_unique (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] {R' : ๐ฎ} {a' : ๐ณ} {g : R' โถ R} {f' : R' โถ S} (hf' : f' = g โซ f)
    (ฯ' : a' โถ b) [IsHomLift p f' ฯ'] (ฯ : a' โถ a) [IsHomLift p g ฯ] (hฯ : ฯ โซ ฯ = ฯ') :
    ฯ = inducedMap p f ฯ hf' ฯ' :=
  (Classical.choose_spec <|
    IsStronglyCartesian.universal_property (p:=p) (f:=f) (ฯ:=ฯ) _ _ hf' ฯ').2 ฯ โจinferInstance, hฯโฉ

/-- Given a diagram:
```
a'        a --ฯ--> b
|         |        |
v         v        v
R' --g--> R --f--> S
```
with `ฯ` a cartesian arrow. Then for any arrow `ฯ' : a' โถ b`, any two arrows `ฯ ฯ' : a' โถ a` such
that `g โซ ฯ = ฯ' = g โซ ฯ'`. Then `ฯ = ฯ'`. -/
protected lemma uniqueness (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] {R' : ๐ฎ} {a' : ๐ณ} {g : R' โถ R} {f' : R' โถ S} (hf' : f' = g โซ f)
    (ฯ' : a' โถ b) [IsHomLift p f' ฯ'] {ฯ ฯ' : a' โถ a} [IsHomLift p g ฯ]
    [IsHomLift p g ฯ'] (hcomp : ฯ โซ ฯ = ฯ') (hcomp' : ฯ' โซ ฯ = ฯ') : ฯ = ฯ' := by
  rw [inducedMap_unique p f ฯ hf' ฯ' ฯ hcomp, inducedMap_unique p f ฯ hf' ฯ' ฯ' hcomp']

@[simp]
lemma inducedMap_self_eq_id (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] : inducedMap p f ฯ (id_comp f).symm ฯ = ๐ a := by
  subst_hom_lift p f ฯ; symm
  apply inducedMap_unique
  simp only [id_comp]

/- The composition of two induced maps is also an induced map.
Given a diagrams
```
a''         a'        a --ฯ--> b          a' --ฯ'--> b          a'' --ฯ''--> b
|           |         |        |    and   |          |    and   |            |
v           v         v        v          v          v          v            v
R'' --h'--> R' --h--> R --f--> S          R' --f'--> S          R'' --f''--> S
```
such that `ฯ` and `ฯ'` are cartesian arrows. Composing the induced map from `a'' โถ a'` with the
induced map from `a' โถ a` gives the induced map from `a'' โถ a`. -/
@[simp]
lemma inducedMap_inducedMap (p : ๐ณ โฅค ๐ฎ) {R R' R'' S: ๐ฎ} {a a' a'' b : ๐ณ}
    {f : R โถ S} {f' : R' โถ S} {f'' : R'' โถ S} {g : R' โถ R} {h : R'' โถ R'}
    (H : f' = g โซ f) (H' : f'' = h โซ f') {ฯ : a โถ b} {ฯ' : a' โถ b} {ฯ'' : a'' โถ b}
    [IsStronglyCartesian p f ฯ] [IsStronglyCartesian p f' ฯ'] [IsHomLift p f'' ฯ''] :
    inducedMap p f' ฯ' H' ฯ'' โซ inducedMap p f ฯ H ฯ' =
      inducedMap p f ฯ (show f'' = (h โซ g) โซ f by rwa [assoc, โ H]) ฯ'' := by
  apply inducedMap_unique p f ฯ
  simp only [assoc, inducedMap_comp]

/-- Given two cartesian arrows `ฯ`, `ฯ` as follows
```
a --ฯ--> b --ฯ--> c
|        |        |
v        v        v
R --f--> S --g--> T
```
Then the composite `ฯ โซ ฯ` is also cartesian. -/
instance comp (p : ๐ณ โฅค ๐ฎ) {R S T : ๐ฎ} {a b c: ๐ณ} (f : R โถ S) (g : S โถ T) (ฯ : a โถ b)
    (ฯ : b โถ c) [IsStronglyCartesian p f ฯ] [IsStronglyCartesian p g ฯ] :
      IsStronglyCartesian p (f โซ g) (ฯ โซ ฯ) := by
  apply IsStronglyCartesian.mk
  ยท intro a' h ฯ hฯ
    -- TODO: can simplify this line??
    use inducedMap p f ฯ (rfl (a := h โซ f)) (inducedMap p g ฯ (assoc h f g).symm ฯ)
    refine โจโจinferInstance, ?_โฉ, ?_โฉ
    ยท rw [โ assoc, inducedMap_comp, inducedMap_comp]
    ยท intro ฯ' โจhฯ'โ, hฯ'โโฉ
      apply inducedMap_unique
      apply inducedMap_unique
      simp only [assoc, hฯ'โ]

/-- Given two commutative squares
```
a --ฯ--> b --ฯ--> c
|        |        |
v        v        v
R --f--> S --g--> T
```
such that the composite `ฯ โซ ฯ` and `ฯ` are cartesian, then so is `ฯ`. -/
protected lemma of_comp (p : ๐ณ โฅค ๐ฎ) {R S T : ๐ฎ} {a b c: ๐ณ} {f : R โถ S} {g : S โถ T}
    {ฯ : a โถ b} {ฯ : b โถ c} [IsStronglyCartesian p g ฯ] [IsStronglyCartesian p (f โซ g) (ฯ โซ ฯ)]
    [IsHomLift p f ฯ] : IsStronglyCartesian p f ฯ := by
  apply IsStronglyCartesian.mk
  -- Fix a morphism `ฯ : a' โถ b` and a morphism `h : p(a') โถ R` such that `ฯ` lifts `h โซ f`
  intro a' h ฯ hฯ
  have hโ : IsHomLift p (h โซ f โซ g) (ฯ โซ ฯ) := by simpa using IsHomLift.comp (h โซ f) _ ฯ ฯ
  -- We get a morphism `ฯ : a' โถ a` from the universal property of `ฯ โซ ฯ`
  use inducedMap p (f โซ g) (ฯ โซ ฯ) (f' := h โซ f โซ g) rfl (ฯ โซ ฯ)
  refine โจโจinferInstance, ?_โฉ,?_โฉ
  -- The fact that `ฯ โซ ฯ = ฯ` follows from `ฯ โซ ฯ โซ ฯ = ฯ โซ ฯ` and the universal property of `ฯ`
  ยท apply IsStronglyCartesian.uniqueness p g ฯ (g := h โซ f) rfl (ฯ โซ ฯ) (by simp) rfl
  -- Finally, uniqueness of `ฯ` comes from the universal property of `ฯ โซ ฯ`
  intro ฯ' โจhฯ'โ, hฯ'โโฉ
  apply inducedMap_unique
  simp [hฯ'โ.symm]

instance of_iso (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โ b) [IsHomLift p f ฯ.hom] :
    IsStronglyCartesian p f ฯ.hom := by
  apply IsStronglyCartesian.mk
  intro a' g ฯ hฯ
  use ฯ โซ ฯ.inv
  refine โจ?_, by aesop_catโฉ
  simpa using (IsHomLift.comp (g โซ f) (isoOfIsoLift p f ฯ).inv ฯ ฯ.inv)

instance of_isIso (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b) [IsHomLift p f ฯ]
    [IsIso ฯ] : IsStronglyCartesian p f ฯ :=
  -- TODO: this is also annoying to have to state
  have : p.IsHomLift f (asIso ฯ).hom := by aesop
  IsStronglyCartesian.of_iso p f (asIso ฯ)

/-- A cartesian arrow lying over an isomorphism is an isomorphism. -/
lemma isIso_of_base_isIso (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    [IsStronglyCartesian p f ฯ] (hf : IsIso f) : IsIso ฯ := by
  -- The inverse will be given by applying the universal property to the arrows fโปยน : S โถ R and ๐ b
  -- TODO: this is annoying because now we have to state p.map ฯ instead of f....
  subst_hom_lift p f ฯ; clear a b R S -- TODO: make this into meta-code
  let ฯ' := inducedMap p (p.map ฯ) ฯ (IsIso.inv_hom_id (p.map ฯ)).symm (๐ b)
  use ฯ'
  -- `ฯ' โซ ฯ = ๐ b` follows immediately from the universal property
  have inv_hom : ฯ' โซ ฯ = ๐ b := inducedMap_comp p (p.map ฯ) ฯ _ (๐ b)
  refine โจ?_, inv_homโฉ
  -- We now show that `ฯ โซ ฯ' = ๐ a` by applying the universal property of `ฯ` to the equality
  -- `ฯ โซ ฯ' โซ ฯ = ฯ โซ ๐ b = ๐ a โซ ฯ`
  have hโ : IsHomLift p (๐ (p.obj a)) (ฯ  โซ ฯ') := by
    rw [โ IsIso.hom_inv_id (p.map ฯ)]
    apply IsHomLift.comp
  have hโ : IsHomLift p (p.map ฯ) (ฯ โซ ฯ' โซ ฯ) := by
    simpa using IsHomLift.comp (๐ (p.obj a)) (p.map ฯ) (ฯ โซ ฯ') ฯ
  apply IsStronglyCartesian.uniqueness p _ ฯ (id_comp (p.map ฯ)).symm (ฯ โซ ฯ' โซ ฯ)
  ยท apply Category.assoc
  ยท simp only [inv_hom, id_comp, comp_id]

/-- The canonical isomorphism between the domains of two cartesian arrows lying over
isomorphic objects. -/
noncomputable def isoOfBaseIso (p : ๐ณ โฅค ๐ฎ) {R R' S : ๐ฎ} {a a' b : ๐ณ} {f : R โถ S} {f' : R' โถ S}
  {g : R' โ R} (h : f' = g.hom โซ f) (ฯ : a โถ b) (ฯ' : a' โถ b) [IsStronglyCartesian p f ฯ]
    [IsStronglyCartesian p f' ฯ'] : a' โ a where
  hom := inducedMap p f ฯ h ฯ'
  -- TODO: make this cleaner...
  inv := @inducedMap _ _ _ _ p _ _ _ _ f' ฯ' _ _ _ _ _ (congrArg (g.inv โซ ยท) h.symm) ฯ
    (by simp; infer_instance)

/-- The canonical isomorphism between the domains of two cartesian arrows
lying over the same object. -/
noncomputable def naturalIso (p : ๐ณ โฅค ๐ฎ) {R S : ๐ฎ} {a' a b : ๐ณ} (f : R โถ S) (ฯ : a โถ b)
    (ฯ' : a' โถ b) [IsStronglyCartesian p f ฯ] [IsStronglyCartesian p f ฯ'] : a' โ a :=
  isoOfBaseIso p (show f = (Iso.refl R).hom โซ f by simp) ฯ ฯ'

end IsStronglyCartesian

end CategoryTheory
