/-
Copyright (c) 2021 Aaron Anderson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson, Antoine Chambert-Loir
-/
import Mathlib.Algebra.Ring.CharZero
import Mathlib.Data.Fintype.Units
import Mathlib.GroupTheory.IndexNormal
import Mathlib.GroupTheory.Perm.Fin
import Mathlib.GroupTheory.Subgroup.Simple
import Mathlib.GroupTheory.Perm.Cycle.Concrete
import Mathlib.GroupTheory.SpecificGroups.Cyclic
import Mathlib.Logic.Equiv.Fin.Rotate
import Mathlib.Tactic.IntervalCases

/-!
# Alternating Groups

The alternating group on a finite type `α` is the subgroup of the permutation group `Perm α`
consisting of the even permutations.

## Main definitions

* `alternatingGroup α` is the alternating group on `α`, defined as a `Subgroup (Perm α)`.

## Main results
* `alternatingGroup.index_eq_two` shows that the index of the alternating group is two.

* `two_mul_card_alternatingGroup` shows that the alternating group is half as large as
  the permutation group it is a subgroup of.

* `closure_three_cycles_eq_alternating` shows that the alternating group is
  generated by 3-cycles.

* `alternatingGroup.isSimpleGroup_five` shows that the alternating group on `Fin 5` is simple.
  The proof shows that the normal closure of any non-identity element of this group contains a
  3-cycle.

* `Equiv.Perm.eq_alternatingGroup_of_index_eq_two` shows that a subgroup of index 2
  of `Equiv.Perm α` is the alternating group.

* `Equiv.Perm.alternatingGroup_le_of_index_le_two` shows that a subgroup of index at most 2
  of `Equiv.Perm α` contains the alternating group.

## Instances

* The alternating group is a characteristic subgroup of the permutaiton group.

## Tags
alternating group permutation simple characteristic index


-/

-- An example on how to determine the order of an element of a finite group.
example : orderOf (-1 : ℤˣ) = 2 :=
  orderOf_eq_prime (Int.units_sq _) (by decide)

open Equiv Equiv.Perm Subgroup Fintype

variable (α : Type*) [Fintype α] [DecidableEq α]

/-- The alternating group on a finite type, realized as a subgroup of `Equiv.Perm`.
  For $A_n$, use `alternatingGroup (Fin n)`. -/
def alternatingGroup : Subgroup (Perm α) :=
  sign.ker

instance alternatingGroup.instFintype : Fintype (alternatingGroup α) :=
  @Subtype.fintype _ _ sign.decidableMemKer _

instance [Subsingleton α] : Unique (alternatingGroup α) :=
  ⟨⟨1⟩, fun ⟨p, _⟩ => Subtype.eq (Subsingleton.elim p _)⟩

variable {α}

theorem alternatingGroup_eq_sign_ker : alternatingGroup α = sign.ker :=
  rfl

namespace Equiv.Perm

@[simp]
theorem mem_alternatingGroup {f : Perm α} : f ∈ alternatingGroup α ↔ sign f = 1 :=
  sign.mem_ker

theorem prod_list_swap_mem_alternatingGroup_iff_even_length {l : List (Perm α)}
    (hl : ∀ g ∈ l, IsSwap g) : l.prod ∈ alternatingGroup α ↔ Even l.length := by
  rw [mem_alternatingGroup, sign_prod_list_swap hl, neg_one_pow_eq_one_iff_even]
  decide

theorem IsThreeCycle.mem_alternatingGroup {f : Perm α} (h : IsThreeCycle f) :
    f ∈ alternatingGroup α :=
  Perm.mem_alternatingGroup.mpr h.sign

theorem finRotate_bit1_mem_alternatingGroup {n : ℕ} :
    finRotate (2 * n + 1) ∈ alternatingGroup (Fin (2 * n + 1)) := by
  rw [mem_alternatingGroup, sign_finRotate, pow_mul, pow_two, Int.units_mul_self, one_pow]

end Equiv.Perm

@[simp]
theorem alternatingGroup.index_eq_two [Nontrivial α] :
    (alternatingGroup α).index = 2 := by
  rw [alternatingGroup, index_ker, MonoidHom.range_eq_top.mpr (sign_surjective α)]
  simp_rw [mem_top, Nat.card_eq_fintype_card, card_subtype_true, card_units_int]

@[nontriviality]
theorem alternatingGroup.index_eq_one [Subsingleton α] : (alternatingGroup α).index = 1 := by
  rw [Subgroup.index_eq_one]; apply Subsingleton.elim

open MulAction in
lemma alternatingGroup.map_extendDomainHom_finSuccAboveEquiv {n} (i : Fin (n + 1)) :
    (alternatingGroup (Fin n)).map (extendDomainHom (finSuccAboveEquiv i)) =
      alternatingGroup (Fin (n + 1)) ⊓ stabilizer (Perm (Fin (n + 1))) i := by
  ext1 p
  suffices (∃ q, sign q = 1 ∧ q.extendDomain (finSuccAboveEquiv i) = p) ↔
      sign p = 1 ∧ p i = i by simpa
  constructor
  case mp =>
    rintro ⟨q, hq, rfl⟩; simp [hq, Equiv.Perm.extendDomain_apply_not_subtype]
  case mpr =>
    rintro ⟨esp, epi⟩
    have hp₁ : ∀ j, j ≠ i ↔ p j ≠ i := by
      simpa [not_iff_not, p.apply_eq_iff_eq_symm_apply] using epi
    use (finSuccAboveEquiv i).permCongr.symm (subtypePerm (p := fun j => j ≠ i) p hp₁)
    constructor
    · have hp₂ : ∀ j, p j ≠ j → j ≠ i := by simp [not_imp_not, epi]
      simp [sign_subtypePerm p hp₁ hp₂, esp]
    ext1 j
    by_cases hj : j = i
    case pos => subst hj; simp [extendDomain_apply_not_subtype, epi]
    case neg => simp [extendDomain_apply_subtype, hj]

open MulAction in
lemma alternatingGroup.map_extendDomainHom_finSuccAboveEquiv_le_alternatingGroup
    {n} (i : Fin (n + 1)) :
    (alternatingGroup (Fin n)).map (extendDomainHom (finSuccAboveEquiv i))
      ≤ alternatingGroup (Fin (n + 1)) := by
  rw [alternatingGroup.map_extendDomainHom_finSuccAboveEquiv]; apply inf_le_left

theorem two_mul_card_alternatingGroup [Nontrivial α] :
    2 * card (alternatingGroup α) = card (Perm α) := by
  simp only [← Nat.card_eq_fintype_card, ← alternatingGroup.index_eq_two (α := α), index_mul_card]

namespace alternatingGroup

open Equiv.Perm

instance normal : (alternatingGroup α).Normal :=
  sign.normal_ker

theorem isConj_of {σ τ : alternatingGroup α} (hc : IsConj (σ : Perm α) (τ : Perm α))
    (hσ : (σ : Perm α).support.card + 2 ≤ Fintype.card α) : IsConj σ τ := by
  obtain ⟨σ, hσ⟩ := σ
  obtain ⟨τ, hτ⟩ := τ
  obtain ⟨π, hπ⟩ := isConj_iff.1 hc
  rw [Subtype.coe_mk, Subtype.coe_mk] at hπ
  rcases Int.units_eq_one_or (Perm.sign π) with h | h
  · rw [isConj_iff]
    refine ⟨⟨π, mem_alternatingGroup.mp h⟩, Subtype.val_injective ?_⟩
    simpa only [Subtype.val, Subgroup.coe_mul, coe_inv, coe_mk] using hπ
  · have h2 : 2 ≤ σ.supportᶜ.card := by
      rw [Finset.card_compl, le_tsub_iff_left σ.support.card_le_univ]
      exact hσ
    obtain ⟨a, ha, b, hb, ab⟩ := Finset.one_lt_card.1 h2
    refine isConj_iff.2 ⟨⟨π * swap a b, ?_⟩, Subtype.val_injective ?_⟩
    · rw [mem_alternatingGroup, MonoidHom.map_mul, h, sign_swap ab, Int.units_mul_self]
    · simp only [← hπ, coe_mk, Subgroup.coe_mul, Subtype.val]
      have hd : Disjoint (swap a b) σ := by
        rw [disjoint_iff_disjoint_support, support_swap ab, Finset.disjoint_insert_left,
          Finset.disjoint_singleton_left]
        exact ⟨Finset.mem_compl.1 ha, Finset.mem_compl.1 hb⟩
      rw [mul_assoc π _ σ, hd.commute.eq, coe_inv, coe_mk]
      simp [mul_assoc]

theorem isThreeCycle_isConj (h5 : 5 ≤ Fintype.card α) {σ τ : alternatingGroup α}
    (hσ : IsThreeCycle (σ : Perm α)) (hτ : IsThreeCycle (τ : Perm α)) : IsConj σ τ :=
  alternatingGroup.isConj_of (isConj_iff_cycleType_eq.2 (hσ.trans hτ.symm))
    (by rwa [hσ.card_support])

end alternatingGroup

namespace Equiv.Perm

open alternatingGroup

@[simp]
theorem closure_three_cycles_eq_alternating :
    closure { σ : Perm α | IsThreeCycle σ } = alternatingGroup α :=
  closure_eq_of_le _ (fun _ hσ => mem_alternatingGroup.2 hσ.sign) fun σ hσ => by
    suffices hind :
      ∀ (n : ℕ) (l : List (Perm α)) (_ : ∀ g, g ∈ l → IsSwap g) (_ : l.length = 2 * n),
        l.prod ∈ closure { σ : Perm α | IsThreeCycle σ } by
      obtain ⟨l, rfl, hl⟩ := truncSwapFactors σ
      obtain ⟨n, hn⟩ := (prod_list_swap_mem_alternatingGroup_iff_even_length hl).1 hσ
      rw [← two_mul] at hn
      exact hind n l hl hn
    intro n
    induction' n with n ih <;> intro l hl hn
    · simp [List.length_eq_zero_iff.1 hn, one_mem]
    rw [Nat.mul_succ] at hn
    obtain ⟨a, l, rfl⟩ := l.exists_of_length_succ hn
    rw [List.length_cons, Nat.succ_inj'] at hn
    obtain ⟨b, l, rfl⟩ := l.exists_of_length_succ hn
    rw [List.prod_cons, List.prod_cons, ← mul_assoc]
    rw [List.length_cons, Nat.succ_inj'] at hn
    exact
      mul_mem
        (IsSwap.mul_mem_closure_three_cycles (hl a (List.mem_cons_self a _))
          (hl b (List.mem_cons_of_mem a (l.mem_cons_self b))))
        (ih _ (fun g hg => hl g (List.mem_cons_of_mem _ (List.mem_cons_of_mem _ hg))) hn)

/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on
  at least 5 elements is the entire alternating group if it contains a 3-cycle. -/
theorem IsThreeCycle.alternating_normalClosure (h5 : 5 ≤ Fintype.card α) {f : Perm α}
    (hf : IsThreeCycle f) :
    normalClosure ({⟨f, hf.mem_alternatingGroup⟩} : Set (alternatingGroup α)) = ⊤ :=
  eq_top_iff.2
    (by
      have hi : Function.Injective (alternatingGroup α).subtype := Subtype.coe_injective
      refine eq_top_iff.1 (map_injective hi (le_antisymm (map_mono le_top) ?_))
      rw [← MonoidHom.range_eq_map, range_subtype, normalClosure, MonoidHom.map_closure]
      refine (le_of_eq closure_three_cycles_eq_alternating.symm).trans (closure_mono ?_)
      intro g h
      obtain ⟨c, rfl⟩ := isConj_iff.1 (isConj_iff_cycleType_eq.2 (hf.trans h.symm))
      refine ⟨⟨c * f * c⁻¹, h.mem_alternatingGroup⟩, ?_, rfl⟩
      rw [Group.mem_conjugatesOfSet_iff]
      exact ⟨⟨f, hf.mem_alternatingGroup⟩, Set.mem_singleton _, isThreeCycle_isConj h5 hf h⟩)

/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in
  its cycle decomposition is a 3-cycle, so the normal closure of the original element must be
  $A_5$. -/
theorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 ∈ cycleType g) :
    IsThreeCycle (g * g) := by
  obtain ⟨c, g', rfl, hd, _, h3⟩ := mem_cycleType_iff.1 h
  simp only [mul_assoc]
  rw [hd.commute.eq, ← mul_assoc g']
  suffices hg' : orderOf g' ∣ 2 by
    rw [← pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]
    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq
  rw [← lcm_cycleType, Multiset.lcm_dvd]
  intro n hn
  rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]
  apply le_of_add_le_add_left
  rw [← hd.card_support_mul, h3]
  exact (c * g').support.card_le_univ

end Equiv.Perm

namespace alternatingGroup

open Equiv.Perm

theorem eq_bot_of_card_le_two (h2 : card α ≤ 2) : alternatingGroup α = ⊥ := by
  nontriviality α
  suffices hα' : card α = 2 by
    rw [Subgroup.eq_bot_iff_card, ← Nat.mul_right_inj (a := 2) (by norm_num),
      Nat.card_eq_fintype_card, two_mul_card_alternatingGroup, mul_one, card_perm, hα',
      Nat.factorial_two]
  exact h2.antisymm Fintype.one_lt_card

theorem nontrivial_of_three_le_card (h3 : 3 ≤ card α) : Nontrivial (alternatingGroup α) := by
  haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)
  rw [← Fintype.one_lt_card_iff_nontrivial]
  refine lt_of_mul_lt_mul_left ?_ (le_of_lt Nat.prime_two.pos)
  rw [two_mul_card_alternatingGroup, card_perm, ← Nat.succ_le_iff]
  exact le_trans h3 (card α).self_le_factorial

instance {n : ℕ} : Nontrivial (alternatingGroup (Fin (n + 3))) :=
  nontrivial_of_three_le_card
    (by
      rw [card_fin]
      exact le_add_left (le_refl 3))

lemma isCyclic_of_card_eq_three (h3 : card α = 3) : IsCyclic ↥(alternatingGroup α) := by
  haveI : Nontrivial α := Fintype.one_lt_card_iff_nontrivial.1 (by rw [h3]; omega)
  haveI : Fact (Nat.Prime 3) := ⟨by decide⟩
  apply isCyclic_of_prime_card (p := 3)
  have := two_mul_card_alternatingGroup (α := α)
  rw [card_perm, h3, show Nat.factorial 3 = 6 from rfl] at this
  rw [Nat.card_eq_fintype_card]; omega

def kleinFour : Subgroup (Perm (Fin 4)) where
  carrier := {1, swap 0 1 * swap 2 3, swap 0 2 * swap 1 3, swap 0 3 * swap 1 2}
  mul_mem' := by decide
  one_mem' := by dsimp only; decide
  inv_mem' := by dsimp only; decide

lemma mem_kleinFour {p : Perm (Fin 4)} :
    p ∈ kleinFour ↔ p.cycleType ∈ ({0, {2, 2}} : Set (Multiset ℕ)) := by
  constructor
  case mp =>
    revert p
    simp_rw [← mem_carrier, kleinFour]; decide
  case mpr =>
    intro hp; rw [Set.mem_insert_iff, Set.mem_singleton_iff, cycleType_eq_zero] at hp
    obtain (rfl | hp) := hp
    · simp [kleinFour]
    have support_eq_pair_iff {p : Perm (Fin 4)} {m n : Fin 4} (hmn : m ≠ n) :
        p.support = {m, n} ↔ p = swap m n := by
      constructor
      case mpr => rintro rfl; exact support_swap hmn
      intro hp; have hp₂ : p.IsSwap := by simpa [hmn] using congr_arg Finset.card hp
      obtain ⟨m', n', hmn', rfl⟩ := hp₂
      rw [support_swap hmn'] at hp
      by_cases hmm' : m' = m
      case pos =>
        subst hmm'; replace hp : n' ∈ ({m', n} : Finset (Fin 4)) := by rw [← hp]; simp
        obtain rfl : n' = n := by simpa [hmn'.symm] using hp
        rfl
      case neg =>
        have hm' : m' ∈ ({m, n} : Finset (Fin 4)) := by rw [← hp]; simp
        obtain rfl : m' = n := by simpa [hmm'] using hm'
        clear hmm' hm'; replace hp : n' ∈ ({m, m'} : Finset (Fin 4)) := by rw [← hp]; simp
        obtain rfl : n' = m := by simpa [hmn'.symm] using hp
        apply swap_comm
    replace hp : ∃ᵉ (n ∈ ({0}ᶜ : Finset (Fin 4))) (s : Perm (Fin 4)),
        s.support = ({0, n}ᶜ : Finset (Fin 4)) ∧ p = swap 0 n * s := by
      replace hp : ∃ (s₀ s₁ : Perm (Fin 4)),
          s₀.IsSwap ∧ s₁.IsSwap ∧ s₀.Disjoint s₁ ∧ 0 ∈ s₀.support ∧ p = s₀ * s₁ := by
        have h0 : 0 ∈ p.support := by
          convert Finset.mem_univ (0 : Fin 4) using 1
          rw [← Finset.card_eq_iff_eq_univ, card_fin, ← sum_cycleType, hp]; rfl
        have : 2 ∈ p.cycleType := by rw [hp]; decide
        rw [mem_cycleType_iff] at this; obtain ⟨s₀, s₁, rfl, hs₀s₁, -, hs₀⟩ := this
        rw [card_support_eq_two] at hs₀
        rw [hs₀s₁.cycleType_mul, hs₀.isCycle.cycleType, card_support_eq_two.mpr hs₀,
          Multiset.singleton_add, Multiset.insert_eq_cons, Multiset.cons_inj_right] at hp
        replace hp := congr_arg Multiset.sum hp
        rw [Multiset.sum_singleton, sum_cycleType, card_support_eq_two] at hp
        rw [hs₀s₁.support_mul, Finset.mem_union] at h0
        obtain (h0s₀ | hs0s₁) := h0
        case inl => exact ⟨s₀, s₁, hs₀, hp, hs₀s₁, h0s₀, rfl⟩
        case inr => exact ⟨s₁, s₀, hp, hs₀, disjoint_comm.mp hs₀s₁, hs0s₁, hs₀s₁.commute⟩
      obtain ⟨s₀, s₁, hs₀, hs₁, hs₀s₁, h0s₁, rfl⟩ := hp
      obtain ⟨n, hn, rfl⟩ : ∃ (n : Fin 4), n ≠ 0 ∧ s₀ = swap 0 n := by
        obtain ⟨m, n, hmn, rfl⟩ := hs₀
        simp_rw [support_swap hmn, Finset.mem_insert, Finset.mem_singleton] at h0s₁
        obtain (rfl | rfl) := h0s₁
        case inl => exact ⟨n, hmn.symm, rfl⟩
        case inr => exact ⟨m, hmn, swap_comm m 0⟩
      clear hs₀ h0s₁
      refine ⟨n, by simpa using hn, s₁, ?_, rfl⟩
      rw [disjoint_iff_disjoint_support, support_swap hn.symm,
        ← le_compl_iff_disjoint_left, Finset.le_iff_subset] at hs₀s₁
      rw [← Finset.eq_iff_card_le_of_subset hs₀s₁, Finset.card_compl, card_fin]
      simp [hn.symm, card_support_eq_two.mpr hs₁]
    obtain ⟨n, hn, s, hs, rfl⟩ := hp
    conv at hn => arg 1; equals {1, 2, 3} => decide
    fin_cases hn
    · conv_rhs at hs => equals {2, 3} => decide
      rw [support_eq_pair_iff (by decide)] at hs; subst hs
      simp [kleinFour]
    · conv_rhs at hs => equals {1, 3} => decide
      rw [support_eq_pair_iff (by decide)] at hs; subst hs
      simp [kleinFour]
    · conv_rhs at hs => equals {1, 2} => decide
      rw [support_eq_pair_iff (by decide)] at hs; subst hs
      simp [kleinFour]

instance : kleinFour.Normal where
  conj_mem := by simp [mem_kleinFour]

lemma kleinFour_le_alternatingGroup : kleinFour ≤ alternatingGroup (Fin 4) := by
  simp_rw [SetLike.le_def, mem_kleinFour, mem_alternatingGroup, sign_of_cycleType,
    Set.mem_insert_iff, Set.mem_singleton_iff]
  rintro p (hp | hp) <;> simp (disch := decide) [hp]

/-- The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be
  used to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/
theorem normalClosure_finRotate_five : normalClosure ({⟨finRotate 5,
    finRotate_bit1_mem_alternatingGroup (n := 2)⟩} : Set (alternatingGroup (Fin 5))) = ⊤ :=
  eq_top_iff.2
    (by
      have h3 :
        IsThreeCycle (Fin.cycleRange 2 * finRotate 5 * (Fin.cycleRange 2)⁻¹ * (finRotate 5)⁻¹) :=
        card_support_eq_three_iff.1 (by decide)
      rw [← h3.alternating_normalClosure (by rw [card_fin])]
      refine normalClosure_le_normal ?_
      rw [Set.singleton_subset_iff, SetLike.mem_coe]
      have h :
        (⟨finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)⟩ : alternatingGroup (Fin 5)) ∈
          normalClosure _ :=
        SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))
      -- Porting note: added `:` to help the elaborator
      exact (mul_mem (Subgroup.normalClosure_normal.conj_mem _ h
        ⟨Fin.cycleRange 2, Fin.isThreeCycle_cycleRange_two.mem_alternatingGroup⟩) (inv_mem h) :))

/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be
used to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.
-/
theorem normalClosure_swap_mul_swap_five :
    normalClosure
        ({⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩} :
          Set (alternatingGroup (Fin 5))) =
      ⊤ := by
  let g1 := (⟨swap 0 2 * swap 0 1, mem_alternatingGroup.2 (by decide)⟩ : alternatingGroup (Fin 5))
  let g2 := (⟨swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)⟩ : alternatingGroup (Fin 5))
  have h5 : g1 * g2 * g1⁻¹ * g2⁻¹ =
      ⟨finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)⟩ := by
    rw [Subtype.ext_iff]
    simp only [Fin.val_mk, Subgroup.coe_mul, Subgroup.coe_inv, Fin.val_mk]
    decide
  rw [eq_top_iff, ← normalClosure_finRotate_five]
  refine normalClosure_le_normal ?_
  rw [Set.singleton_subset_iff, SetLike.mem_coe, ← h5]
  have h : g2 ∈ normalClosure {g2} :=
    SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))
  exact mul_mem (Subgroup.normalClosure_normal.conj_mem _ h g1) (inv_mem h)

/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps
  is conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation
  in $A_5$ is $A_5$. -/
theorem isConj_swap_mul_swap_of_cycleType_two {g : Perm (Fin 5)} (ha : g ∈ alternatingGroup (Fin 5))
    (h1 : g ≠ 1) (h2 : ∀ n, n ∈ cycleType (g : Perm (Fin 5)) → n = 2) :
    IsConj (swap 0 4 * swap 1 3) g := by
  have h := g.support.card_le_univ
  rw [← Multiset.eq_replicate_card] at h2
  rw [← sum_cycleType, h2, Multiset.sum_replicate, smul_eq_mul] at h
  have h : Multiset.card g.cycleType ≤ 3 :=
    le_of_mul_le_mul_right (le_trans h (by norm_num only [card_fin])) (by simp)
  rw [mem_alternatingGroup, sign_of_cycleType, h2] at ha
  norm_num at ha
  rw [pow_add, pow_mul, Int.units_pow_two, one_mul, neg_one_pow_eq_one_iff_even] at ha
  swap; · decide
  rw [isConj_iff_cycleType_eq, h2]
  interval_cases h_1 : Multiset.card g.cycleType
  · exact (h1 (card_cycleType_eq_zero.1 h_1)).elim
  · simp at ha
  · have h04 : (0 : Fin 5) ≠ 4 := by decide
    have h13 : (1 : Fin 5) ≠ 3 := by decide
    rw [Disjoint.cycleType, (isCycle_swap h04).cycleType, (isCycle_swap h13).cycleType,
      card_support_swap h04, card_support_swap h13]
    · simp
    · rw [disjoint_iff_disjoint_support, support_swap h04, support_swap h13]
      decide
  · contradiction

lemma isSimpleGroup_of_card_eq_three (h3 : card α = 3) : IsSimpleGroup ↥(alternatingGroup α) := by
  haveI : Nontrivial α := Fintype.one_lt_card_iff_nontrivial.1 (by rw [h3]; omega)
  haveI : Fact (Nat.Prime 3) := ⟨by decide⟩
  apply isSimpleGroup_of_prime_card (p := 3)
  have := two_mul_card_alternatingGroup (α := α)
  rw [card_perm, h3, show Nat.factorial 3 = 6 from rfl] at this
  rw [Nat.card_eq_fintype_card]; omega

instance isSimpleGroup_three : IsSimpleGroup ↥(alternatingGroup (Fin 3)) := by
  apply isSimpleGroup_of_card_eq_three; simp

set_option push_neg.use_distrib true in
theorem not_isSimpleGroup_four : ¬IsSimpleGroup ↥(alternatingGroup (Fin 4)) := by
  simp_rw [Subgroup.isSimpleGroup_iff, le_antisymm_iff]; push_neg; right
  use kleinFour, kleinFour_le_alternatingGroup, inferInstance
  constructor
  case left =>
    left; simp_rw [SetLike.not_le_iff_exists, mem_bot, ← mem_carrier, kleinFour]
    use swap 0 1 * swap 2 3; decide
  case right =>
    right; simp_rw [SetLike.not_le_iff_exists, mem_alternatingGroup, ← mem_carrier, kleinFour]
    use Fin.cycleRange 2; decide

theorem not_isSimpleGroup_of_card_eq_four (h4 : card α = 4) :
    ¬IsSimpleGroup ↥(alternatingGroup α) := by
  intro hsa
  obtain ⟨e⟩ := Fintype.truncEquivFin α
  have me : ↥(alternatingGroup α) ≃* ↥(alternatingGroup (Fin (card α))) :=
    e.permCongrMulEquiv.subgroupMap (alternatingGroup α) |>.trans <|
      MulEquiv.subgroupCongr <| by
        ext1 p
        simp [e.permCongr.symm.surjective.exists,
          show sign (e.permCongr.symm p) = sign p by simp, - permCongr_symm]
  rw [h4] at me; exact absurd me.symm.isSimpleGroup not_isSimpleGroup_four

/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework
  on its cycle type that its normal closure is all of $A_5$. -/
theorem isSimpleGroup_five : IsSimpleGroup ↥(alternatingGroup (Fin 5)) :=
  ⟨fun H => by
    intro Hn
    refine or_not.imp id fun Hb => ?_
    rw [eq_bot_iff_forall] at Hb
    push_neg at Hb
    obtain ⟨⟨g, gA⟩, gH, g1⟩ : ∃ x : ↥(alternatingGroup (Fin 5)), x ∈ H ∧ x ≠ 1 := Hb
    -- `g` is a non-identity alternating permutation in a normal subgroup `H` of $A_5$.
    rw [← SetLike.mem_coe, ← Set.singleton_subset_iff] at gH
    refine eq_top_iff.2 (le_trans (ge_of_eq ?_) (normalClosure_le_normal gH))
    -- It suffices to show that the normal closure of `g` in $A_5$ is $A_5$.
    by_cases h2 : ∀ n ∈ g.cycleType, n = 2
    -- If the cycle decomposition of `g` consists entirely of swaps, then the cycle type is $(2,2)$.
    -- This means that it is conjugate to $(04)(13)$, whose normal closure is $A_5$.
    · rw [Ne, Subtype.ext_iff] at g1
      exact
        (isConj_swap_mul_swap_of_cycleType_two gA g1 h2).normalClosure_eq_top_of
          normalClosure_swap_mul_swap_five
    push_neg at h2
    obtain ⟨n, ng, n2⟩ : ∃ n : ℕ, n ∈ g.cycleType ∧ n ≠ 2 := h2
    -- `n` is the size of a non-swap cycle in the decomposition of `g`.
    have n2' : 2 < n := lt_of_le_of_ne (two_le_of_mem_cycleType ng) n2.symm
    have n5 : n ≤ 5 := le_trans ?_ g.support.card_le_univ
    -- We check that `2 < n ≤ 5`, so that `interval_cases` has a precise range to check.
    swap
    · obtain ⟨m, hm⟩ := Multiset.exists_cons_of_mem ng
      rw [← sum_cycleType, hm, Multiset.sum_cons]
      exact le_add_right le_rfl
    interval_cases n
    -- This breaks into cases `n = 3`, `n = 4`, `n = 5`.
    -- If `n = 3`, then `g` has a 3-cycle in its decomposition, so `g^2` is a 3-cycle.
    -- `g^2` is in the normal closure of `g`, so that normal closure must be $A_5$.
    · rw [eq_top_iff, ← (isThreeCycle_sq_of_three_mem_cycleType_five ng).alternating_normalClosure
        (by rw [card_fin])]
      refine normalClosure_le_normal ?_
      rw [Set.singleton_subset_iff, SetLike.mem_coe]
      have h := SetLike.mem_coe.1 (subset_normalClosure
        (G := alternatingGroup (Fin 5)) (Set.mem_singleton ⟨g, gA⟩))
      exact mul_mem h h
    · -- The case `n = 4` leads to contradiction, as no element of $A_5$ includes a 4-cycle.
      have con := mem_alternatingGroup.1 gA
      rw [sign_of_cycleType, cycleType_of_card_le_mem_cycleType_add_two (by decide) ng] at con
      have : Odd 5 := by decide
      simp [this] at con
    · -- If `n = 5`, then `g` is itself a 5-cycle, conjugate to `finRotate 5`.
      refine (isConj_iff_cycleType_eq.2 ?_).normalClosure_eq_top_of normalClosure_finRotate_five
      rw [cycleType_of_card_le_mem_cycleType_add_two (by decide) ng, cycleType_finRotate]⟩

open Fin MulAction in
theorem isSimpleGroup_of_five_le {n} (h5 : 5 ≤ n) :
    IsSimpleGroup ↥(alternatingGroup (Fin n)) := by
  induction n, h5 using Nat.le_induction with
  | base => exact isSimpleGroup_five
  | succ m hmn hm =>
    rw [Subgroup.isSimpleGroup_iff]; constructor
    · rw [← nontrivial_iff_ne_bot]; apply nontrivial_of_three_le_card
      rw [card_fin]; omega
    intro H hHa hHn; rw [Classical.or_iff_not_imp_left, ← ne_eq]; intro hHb
    suffices hH : H ⊓ stabilizer (Perm (Fin (m + 1))) (last m) ≠ ⊥ by
      rw [← inf_of_le_left hHa, inf_assoc,
        ← alternatingGroup.map_extendDomainHom_finSuccAboveEquiv] at hH
      replace hm :=
        (alternatingGroup (Fin m)).equivMapOfInjective
          (extendDomainHom (finSuccAboveEquiv (last m))) (extendDomainHom_injective _)
          |>.symm.isSimpleGroup
      rw [Subgroup.isSimpleGroup_iff] at hm
      replace hm :=
        @hm.2 (H ⊓ (alternatingGroup (Fin m)).map (extendDomainHom (finSuccAboveEquiv (last m))))
          inf_le_right (by
            have := inf_subgroupOf_inf_normal_of_left
              (A' := H) (A := alternatingGroup (Fin (m + 1)))
              ((alternatingGroup (Fin m)).map (extendDomainHom (finSuccAboveEquiv (last m))))
            rwa [inf_of_le_right
              (alternatingGroup.map_extendDomainHom_finSuccAboveEquiv_le_alternatingGroup (last m))]
              at this)
      simp_rw [hH, false_or, inf_eq_right] at hm
      replace hm : ∃ p ∈ H, p.IsThreeCycle := by
        use Fin.cycleRange (⟨2, by omega⟩ : Fin m) |>.extendDomain (finSuccAboveEquiv (last m))
        constructor
        case left =>
          refine hm (mem_map_of_mem _ (IsThreeCycle.mem_alternatingGroup ?_))
          simp [IsThreeCycle, show NeZero m by constructor; omega]
        case right => simp [IsThreeCycle, show NeZero m by constructor; omega]
      obtain ⟨p, hpH, hp⟩ := hm
      rw [← hHa.ge_iff_eq, ← subgroupOf_eq_top, eq_top_iff]
      refine eq_top_iff.mp (hp.alternating_normalClosure (by rw [card_fin]; omega)) |>.trans ?_
      rwa [← normalClosure_subset_iff, Set.singleton_subset_iff, SetLike.mem_coe, mem_subgroupOf]
    rw [← nontrivial_iff_ne_bot, nontrivial_iff_exists_ne_one] at hHb ⊢
    simp_rw [mem_inf, mem_stabilizer_iff, Perm.smul_def, and_assoc]
    obtain ⟨σ, hσH, hσ⟩ := hHb
    by_cases hσl : σ (last m) = last m
    case pos => tauto
    rw [← ne_eq] at hσl
    suffices ∃ τ ∈ H, τ (last m) = σ (last m) ∧ τ ≠ σ by
      obtain ⟨τ, hτH, hτσ, hnτσ⟩ := this
      rw [eq_comm, apply_eq_iff_eq_symm_apply, ← Perm.inv_def, eq_comm, ← mul_apply] at hτσ
      rw [ne_eq, eq_comm, ← inv_mul_eq_one, ← ne_eq] at hnτσ
      use σ⁻¹ * τ, mul_mem (inv_mem hσH) hτH
    have hσs : ¬σ.support ⊆ ({last m, σ (last m)} : Finset (Fin (m + 1))) := by
      by_contra! hσs
      replace hσs := congr_arg Finset.card <| subset_antisymm hσs
        (by rwa [Finset.insert_subset_iff, Finset.singleton_subset_iff, apply_mem_support,
          and_self, mem_support])
      rw [Finset.card_pair hσl.symm, card_support_eq_two] at hσs
      replace hσH := hHa hσH; rw [mem_alternatingGroup, hσs.sign_eq] at hσH
      contradiction
    simp_rw [Finset.not_subset, mem_support] at hσs; obtain ⟨j, hjσ, hjl⟩ := hσs
    have hxy := calc (2 : ℕ)
      _ = 6 - Multiset.card {last m, σ (last m), j, σ j} := rfl
      _ ≤ card (Fin (m + 1)) - Multiset.card {last m, σ (last m), j, σ j} := by
        rw [card_fin]; apply Nat.sub_le_sub_right; omega
      _ ≤ card (Fin (m + 1)) - Finset.card {last m, σ (last m), j, σ j} := by
        apply Nat.sub_le_sub_left
        convert Multiset.toFinset_card_le {last m, σ (last m), j, σ j} using 2
        simp
      _ ≤ ({last m, σ (last m), j, σ j}ᶜ : Finset (Fin (m + 1))).card := by
        rw [Finset.card_compl]
    simp_rw [Finset.le_card_iff_exists_subset_card, Finset.card_eq_two] at hxy
    obtain ⟨_, hxys, x, y, hnxy, rfl⟩ := hxy
    have hcnd : (↑[j, x, y] : Cycle (Fin (m + 1))).Nodup := by
      rw [Finset.subset_compl_comm, Finset.subset_iff] at hxys; simp at hxys ⊢; tauto
    have hcnt : (↑[j, x, y] : Cycle (Fin (m + 1))).Nontrivial := by
      rw [Cycle.nontrivial_coe_nodup_iff hcnd]; simp
    let c := Cycle.formPerm (↑[j, x, y] : Cycle (Fin (m + 1))) hcnd
    have ecs : c.support = {j, x, y} := by
      rw [Cycle.support_formPerm _ hcnd hcnt, Cycle.coe_toFinset]; simp
    have hcma : c ∈ alternatingGroup (Fin (m + 1)) := by
      rw [mem_alternatingGroup, Cycle.isCycle_formPerm _ hcnd hcnt |>.sign,
        Cycle.support_formPerm _ hcnd hcnt, Cycle.coe_toFinset, ← List.toFinset_eq hcnd]; rfl
    use c * σ * c⁻¹
    use by
      simp_rw [normal_subgroupOf_iff_le_normalizer hHa, SetLike.le_def,
        mem_alternatingGroup, mem_normalizer_iff] at hHn
      specialize @hHn c hcma σ
      exact hHn.mp hσH
    use by
      have hlnmcs : last m ∉ (c⁻¹).support := by
        simp_rw [support_inv, ecs]
        simp [Finset.subset_iff] at hjl hxys ⊢; tauto
      have hσlnmcs : σ (last m) ∉ c.support := by
        simp [ecs, Finset.subset_iff] at hjl hxys ⊢; tauto
      simp [not_mem_support.mp hlnmcs, not_mem_support.mp hσlnmcs]
    rw [DFunLike.ne_iff]
    use j
    have ecij : c⁻¹ j = y := by
      simp_rw [c, ← Cycle.formPerm_reverse, Cycle.reverse_coe,
        show [j, x, y].reverse = [y, x, j] from rfl,
        Cycle.formPerm_apply_mem_eq_next (↑[y, x, j])
          (Cycle.nodup_reverse_iff.mpr hcnd) j (by simp)]
      simp only [Cycle.next, Cycle.ofList, Quot.hrecOn, Quot.recOn, Quot.rec]
      apply List.next_getLast_cons <;> [simp; skip; rfl; skip] <;>
        simp [Finset.subset_iff] at hxys ⊢ <;> tauto
    simp_rw [Perm.mul_apply, ecij]
    by_cases hσy : σ y ∈ c.support
    case neg =>
      rw [not_mem_support.mp hσy, σ.injective.ne_iff]
      simp [Finset.subset_iff] at hxys; tauto
    case pos =>
      intro ecσy; rw [← apply_mem_support, ecσy, ecs] at hσy
      revert hσy; simp [Finset.subset_iff] at hxys ⊢; tauto

theorem isSimpleGroup_of_five_le_card (h5 : 5 ≤ card α) : IsSimpleGroup ↥(alternatingGroup α) := by
  haveI : IsSimpleGroup ↥(alternatingGroup (Fin (card α))) := isSimpleGroup_of_five_le h5
  obtain ⟨e⟩ := Fintype.truncEquivFin α
  have me : ↥(alternatingGroup α) ≃* ↥(alternatingGroup (Fin (card α))) :=
    e.permCongrMulEquiv.subgroupMap (alternatingGroup α) |>.trans <|
      MulEquiv.subgroupCongr <| by
        ext1 p
        simp [e.permCongr.symm.surjective.exists,
          show sign (e.permCongr.symm p) = sign p by simp, - permCongr_symm]
  exact me.isSimpleGroup

instance isSimpleGroup_add_five (n : ℕ) : IsSimpleGroup ↥(alternatingGroup (Fin (n + 5))) :=
  isSimpleGroup_of_five_le (Nat.le_add_left 5 n)

theorem isSimpleGroup_iff_card_eq_three_or_card_ge_five :
    IsSimpleGroup ↥(alternatingGroup α) ↔ card α = 3 ∨ 5 ≤ card α := by
  by_cases h5 : 5 ≤ card α
  case pos =>
    simp [isSimpleGroup_of_five_le_card h5, h5]
  by_cases h2 : card α ≤ 2
  case pos =>
    simp [Subgroup.isSimpleGroup_iff, eq_bot_of_card_le_two h2,
      show card α ≠ 3 ∧ card α < 5 by omega]
  obtain (h3 | h4) : card α = 3 ∨ card α = 4 := by omega
  · simp [isSimpleGroup_of_card_eq_three h3, h3]
  · simp [not_isSimpleGroup_of_card_eq_four h4, show card α ≠ 3 ∧ card α < 5 by omega]

end alternatingGroup

namespace Equiv.Perm

open Subgroup Group

/-- The alternating group is the only subgroup of index 2 of the permutation group. -/
theorem eq_alternatingGroup_of_index_eq_two {G : Subgroup (Equiv.Perm α)} (hG : G.index = 2) :
    G = alternatingGroup α := by
  nontriviality α
  obtain ⟨_, ⟨a, b, hab, rfl⟩, habG⟩ : ∃ g : Perm α, g.IsSwap ∧ g ∉ G := by
    by_contra! h
    suffices G = ⊤ by rw [this, Subgroup.index_top] at hG; cases hG
    rwa [eq_top_iff, ← closure_isSwap, G.closure_le]
  ext g
  refine swap_induction_on g (iff_of_true G.one_mem <| map_one _) fun g x y hxy ih ↦ ?_
  rw [mul_mem_iff_of_index_two hG, mul_mem_iff_of_index_two alternatingGroup.index_eq_two, ih]
  refine iff_congr (iff_of_false ?_ (by cases (sign_swap hxy).symm.trans ·)) Iff.rfl
  contrapose! habG
  rw [← (isConj_iff.mp <| isConj_swap hxy hab).choose_spec]
  exact (normal_of_index_eq_two hG).conj_mem _ habG _

/-- A subgroup of the permutation group of index ≤ 2 contains the alternating group. -/
theorem alternatingGroup_le_of_index_le_two
    {G : Subgroup (Equiv.Perm α)} (hG : G.index ≤ 2) :
    alternatingGroup α ≤ G := by
  rcases G.index.eq_zero_or_pos with h | h
  · exact (index_ne_zero_of_finite h).elim
  rcases (Nat.succ_le_iff.mpr h).eq_or_gt with h | h
  · exact index_eq_one.mp h ▸ le_top
  rw [eq_alternatingGroup_of_index_eq_two (hG.antisymm h)]

end Equiv.Perm

/-- The alternating group is a characteristic subgroup of the permutation group. -/
instance : (alternatingGroup α).Characteristic where
  fixed φ := by
    nontriviality α
    apply eq_alternatingGroup_of_index_eq_two
    rw [index_comap_of_surjective _ (Equiv.surjective _), alternatingGroup.index_eq_two]
